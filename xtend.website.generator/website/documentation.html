<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Xtend - Modernized Java</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description"
		content="Xtend is a statically typed programming language sitting on top of Java.">
	<meta name="author" content="Sven Efftinge">
	<!--  styles -->
	<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
	<!--[if lt IE 9]>
	  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	
	<!-- Le fav and touch icons -->
	
	<link rel="shortcut icon" href="images/favicon.png">
	
	<link href="css/bootstrap.css" rel="stylesheet" type='text/css'>
	<link href="css/bootstrap-responsive.css" rel="stylesheet" type='text/css'>
	<link href="css/style.css" rel="stylesheet" type='text/css'>
	<link href="css/shield-responsive.css" rel="stylesheet" type='text/css'>
	<link href='css/fonts.css' rel='stylesheet' type='text/css'>
	<link href="css/prettyPhoto.css" rel="stylesheet" media="screen" type='text/css'>
	<link href="google-code-prettify/prettify.css" type="text/css" rel="stylesheet"/>
	<!--[if lt IE 9]>
	<link href="css/iebugs.css" rel="stylesheet" type='text/css'>
	<![endif]-->
	<script src="js/twitter.js" type="text/javascript"></script>
	<script src="js/jquery-1.7.1.min.js"></script>
	<script src="js/jquery.prettyPhoto.js" type="text/javascript"></script>
		<script type="text/javascript">
	     $(document).ready(function() {
			prettyPrint();
			$('a[data-rel]').each(function() {
				$(this).attr('rel', $(this).data('rel'));
			});
			
			$("a[rel^='prettyPhoto']").prettyPhoto({
				animation_speed: 'fast',
				slideshow: 5000,
				autoplay_slideshow: false,
				opacity: 0.80,
				show_title: true,
				theme: 'ligh_square',
				overlay_gallery: false,
				social_tools: false
			});
			$('#nav-outline > li > a').live('click', function() {        
				$(this).parent().find('ul').slideToggle();      
			});
			var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
			po.src = 'https://apis.google.com/js/plusone.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
	     });
		</script>
	<script type="text/javascript">
		var _gaq = _gaq || [];	
	  	_gaq.push([ '_setAccount', 'UA-2429174-4' ]);
		_gaq.push([ '_trackPageview' ]);
		(function() {
			var ga = document.createElement('script');
			ga.type = 'text/javascript';
			ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl'
					: 'http://www')
					+ '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0];
			s.parentNode.insertBefore(ga, s);
		})();
	</script>
</head>
<body>
	<!-- Navbar -->
	<div class="navbar navbar-fixed-top"
		style="border-bottom: 1px solid #000;">
		<div class="navbar-inner">
			<div class="container">
				<a class="btn btn-navbar" data-toggle="collapse"
					data-target=".nav-collapse"> <span class="icon-bar"></span> <span
					class="icon-bar"></span> <span class="icon-bar"></span>
				</a> <a class="brand" href="index.html"></a>
				<div class="nav-collapse collapse" style="height: 0px;">
					<ul class="nav">
						<li ><a href="news.html">News</a></li>
						<li ><a href="download.html">Download</a></li>
						<li class="active"><a href="documentation.html">Documentation</a></li>
						<li ><a href="community.html">Community</a></li>
						<li ><a href="http://xtext.org">Xtext</a></li>
						<li ><a href="http://www.eclipse.org">Eclipse.org</a></li>
					</ul>
				</div>
				<!--/.nav-collapse -->
		        <div class="btn-group pull-right">
		          <g:plusone href="http://www.xtend-lang.org"></g:plusone>
		        </div>
	
			</div>
		</div>
	</div>
	<!-- Navbar End -->
<!--Container-->
<ul id="nav-outline">
	<li>&nbsp;</li>
	<li style="color : #333;">Getting Started</li>
	<li><a href="#Introduction">Introduction</a>
	</li>
	<li><a href="#GettingStarted">Hello World</a>
	</li>
	<li><a href="#moviesExample">The Movies Example</a>
<ul>	<li><a href="#_0">The Data</a></li>
	<li><a href="#_1">Parsing The Data</a></li>
	<li><a href="#_2">Answering Some Questions</a></li>
</ul>	</li>
	<li>&nbsp;</li>
	<li style="color : #333;">Reference Documentation</li>
	<li><a href="#types">Java Interoperability</a>
<ul>	<li><a href="#localTypeInference">Type Inference</a></li>
	<li><a href="#conversionRules">Conversion Rules</a></li>
	<li><a href="#javaInteroperability">Interoperability with Java</a></li>
</ul>	</li>
	<li><a href="#Xtend_Classes_Members">Classes and Members</a>
<ul>	<li><a href="#packageDecl">Package Declaration</a></li>
	<li><a href="#imports">Imports</a></li>
	<li><a href="#Xtend_ClassDeclaration">Class Declaration</a></li>
	<li><a href="#constructors">Constructors</a></li>
	<li><a href="#fields">Fields</a></li>
	<li><a href="#methods">Methods</a></li>
	<li><a href="#Annotations">Annotations</a></li>
	<li><a href="#extensionMethods">Extension Methods</a></li>
	<li><a href="#interfaces">Interface Declaration</a></li>
	<li><a href="#annotationTypeDeclaration">Annotation Type Declaration</a></li>
	<li><a href="#enumTypeDeclaration">Enum Type Declaration</a></li>
	<li><a href="#Nested_Type_Declarations">Nested Type Declarations</a></li>
</ul>	</li>
	<li><a href="#Xtend_Expressions">Expressions</a>
<ul>	<li><a href="#Xtend_Expressions_Literals">Literals</a></li>
	<li><a href="#typeCasts">Type Casts</a></li>
	<li><a href="#operators">Infix Operators and Operator Overloading</a></li>
	<li><a href="#blocks">Blocks</a></li>
	<li><a href="#variableDeclaration">Variable Declarations</a></li>
	<li><a href="#featureCalls">Field Access and Method Invocation</a></li>
	<li><a href="#constructorCall">Constructor Call</a></li>
	<li><a href="#lambdas">Lambda Expressions</a></li>
	<li><a href="#anonymousClasses">Anonymous Classes</a></li>
	<li><a href="#ifExpression">If Expression</a></li>
	<li><a href="#switchExpression">Switch Expression</a></li>
	<li><a href="#forLoop">For Loop</a></li>
	<li><a href="#traditionalForLoop">Basic For Loop</a></li>
	<li><a href="#whileExpression">While Loop</a></li>
	<li><a href="#doWhileExpression">Do-While Loop</a></li>
	<li><a href="#Xtend_Expressions_Return">Return Expression</a></li>
	<li><a href="#Xtend_Expressions_Throw">Throwing Exceptions</a></li>
	<li><a href="#Xtend_Expressions_TryCatch">Try, Catch, Finally</a></li>
	<li><a href="#Xtend_Expressions_Synchronized">Synchronized</a></li>
	<li><a href="#templates">Template Expressions</a></li>
</ul>	</li>
	<li><a href="#activeAnnotations">Active Annotations</a>
<ul>	<li><a href="#active_annotations_processor">Annotation Processor</a></li>
	<li><a href="#active_annotations_expression">On Expressions and Statements</a></li>
	<li><a href="#active_annotations_validation">Custom Compiler Checks</a></li>
	<li><a href="#active_annotation_classpath">Class Path Setup and Testing</a></li>
	<li><a href="#_3">Existing Active Annotations</a></li>
	<li><a href="#propertyAnnotation">@Property</a></li>
	<li><a href="#dataAnnotation">@Data</a></li>
</ul>	</li>
	<li>&nbsp;</li>
	<li style="color : #333;">Additional Resources</li>
	<li><a href="documentation/2.5.0/Xtend%20User%20Guide.pdf">Documentation <img src="images/pdf_icon.gif"></a>
	<li><a href="api/2.5.0/index.html">Runtime Library API</a>
</ul>
<div id="page">  
	<div class="inner">
		<div id="maincontainer" class="container">
			<!-- chapter -->
			<section id="Introduction" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Introduction
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							Xtend is a statically-typed programming language which translates to comprehensible Java source code. 
							Syntactically and semantically Xtend has its roots in the Java programming language but improves on many aspects:
						</p>
						<p>
							</p>
							<ul>
								<li><strong><a href="#extensionMethods">Extension methods</a></strong> - enhance closed types with new functionality</li>
								<li><strong><a href="#lambdas">Lambda Expressions</a></strong> - concise syntax for anonymous function literals</li>
								<li><strong><a href="#activeAnnotations">ActiveAnnotations</a></strong> - annotation processing on steroids</li>
								<li><strong><a href="#operators">Operator overloading</a></strong> - make your libraries even more expressive</li>
								<li><strong><a href="#switchExpression">Powerful switch expressions</a></strong> - type based switching with implicit casts</li>
								<li><strong><a href="#polymorphicDispatch">Multiple dispatch</a></strong> - a.k.a. polymorphic method invocation</li>
								<li><strong><a href="#templates">Template expressions</a></strong> - with intelligent white space handling</li>
								<li><strong><a href="#Xtend_Expressions">No statements</a></strong> - everything is an expression</li>
								<li><strong><a href="#propertyAccess">Properties</a></strong> - shorthands for accessing and defining getters and setter</li>
								<li><strong>Type inference</strong> - you rarely need to write down type signatures anymore</li>
								<li><strong>Full support for Java generics</strong> - including all conformance and conversion rules</li>
								<li><strong>Translates to Java</strong> not bytecode - understand what is going on and use your code for platforms 
								    such as Android or GWT</li>
							</ul>
							<p>
						</p>
						<p>
							Unlike other JVM languages Xtend has <a href="#javaInteroperability">zero interoperability issues</a> with Java:
							Everything you write interacts with Java exactly as expected. At the same time Xtend is much more concise, 
							readable and expressive. Xtend's small library is just a thin layer that provides useful 
							utilities and extensions on top of the Java Development Kit (JDK).
						</p>
						<p>
							Of course, you can call Xtend methods from Java, too, in a completely transparent way. Furthermore, Xtend provides a modern 
							Eclipse-based IDE closely integrated with the Eclipse Java Development Tools (JDT), including features like call-hierarchies, rename refactoring,
							debugging and many more.
						</p>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="GettingStarted" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Hello World
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							The first thing you want to see in any language is a <strong>Hello World</strong> example. 
							In Xtend, that reads as
							</p>
							<pre class="prettyprint lang-xtend linenums">
class HelloWorld {
  def static void main(String[] args) {
    println("Hello World")
  }
}</pre>
							<p>
						</p>
						<p>
							You see that Xtend looks quite similar to Java. At a first glance the main difference seems to be the <code class="prettyprint lang-xtend">def</code>
							keyword to declare a method. Also like in Java it is mandatory to define a class and a main method as the entry point for an application. 
							Admittedly <strong>Hello World</strong> programs are not a particular strength of Xtend. The real expressiveness is unleashed when you do real things
							as you will learn in a second.
						</p>
						<p>
							An Xtend class resides in a plain Eclipse Java project. As soon as the SDK is installed, Eclipse will automatically 
							translate all the classes to Java source code. By default you will find it in a source folder <strong>xtend-gen</strong>.
							The hello world example is translated to the following Java code:
							</p>
							<pre class="prettyprint lang-java linenums">
// Generated Java Source Code
import org.eclipse.xtext.xbase.lib.InputOutput;

public class HelloWorld {
  public static void main(final String[] args) {
    InputOutput.&lt;String&gt;println("Hello World");
  }
}</pre>
							<p>
						</p>
						<p>
							The only surprising fact in the generated Java code may be the referenced library class <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/InputOutput.html"><abbr title="org.eclipse.xtext.xbase.lib.InputOutput">InputOutput</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/InputOutput.java">(src)</a>. 
							It is part of the runtime library and a nice utility that is quite handy when used in expressions.
						</p>
						<p>
							You can put an Xtend class into a source folder of any Java project within Eclipse or any Maven project. If the project is not
							yet configured properly, Eclipse will complain about the missing library. The xtend.lib has to be on the class path. 
							The IDE will provide a quick fix to add it.
						</p>
						<p>
							The next thing you might want to do is materializing one of the example projects into your workspace.
							Right click anywhere in the <strong>Navigator</strong> view in Eclipse and select <strong>New -&gt; Example...</strong>.
						</p>
						<p>
							In the upcoming dialog you will find two examples for Xtend:
						</p>
						<p>
							</p>
							<ul>
								<li><strong>Xtend Introductory Examples</strong> contains a couple of example code snippets illustrating certain
								  aspects and strengths of Xtend. 
								  For instance it shows how to build an API which allows to write code like this:
								<pre class="prettyprint lang-xtend linenums">
assertEquals(42.km/h, (40_000.m + 2.km) / 60.min)</pre>
								  Also the <a href="#moviesExample">movies example</a> explained in detail in <a href="#moviesExample">the next section</a>
								  is included there.</li>
								<li><strong>Xtend Solutions For Euler</strong> contains solutions to some of the problems you will find at <a href="http://projecteuler.net/">Project Euler</a>.
								   These examples are leveraging the whole expressive power of Xtend. For instance <a href="http://projecteuler.net/problem=1">Euler Problem 1</a> can be solved
								   with this expression :
								<pre class="prettyprint lang-xtend linenums">
(1..999).filter[ i | i % 3 == 0 || i % 5 == 0 ].reduce[ i1, i2 | i1 + i2 ]</pre></li>
							</ul>
							<p>
						</p>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="moviesExample" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							The Movies Example
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							The movies example is included in the example project <strong>Xtend Introductory Examples</strong> (src/examples6/Movies.xtend) and is about reading
							a file with data about movies and doing some analysis on it.
						</p>
						<!--  section -->
						<section id="_0" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">The Data</h2>
						<p>
							The movie database is a plain text file (data.csv) with data sets describing movies.
							Here is an example data set:
							</p>
							<pre class="prettyprint lang-xtend linenums">
Naked Lunch  1991  6.9  16578  Biography  Comedy  Drama  Fantasy</pre>
							<p>
						</p>
						<p>
							The values are separated by two spaces. The columns are :
							</p>
							<ol>
								<li>title</li>
								<li>year</li>
								<li>rating</li>
								<li>numberOfVotes</li>
								<li>categories</li>
							</ol>
							<p>
							
							 
							Let us define a data type <code class="prettyprint lang-xtend">Movie</code> representing a data set:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Data class Movie {
  String title
  int year
  double rating
  long numberOfVotes
  Set&lt;String&gt; categories 
}</pre>
							<p>
						</p>
						<p>
							A movie is a POJO with a strongly typed field for each column in the data sets. The <a href="#dataAnnotation">@Data</a>
							annotation will turn the class into an immutable value class, that is it will get 
							</p>
							<ul>
								<li>a getter-method for each field,</li>
								<li>a <code class="prettyprint lang-xtend">hashCode()</code>/<code class="prettyprint lang-xtend">equals()</code> implementation,</li>
								<li>implementation of <code class="prettyprint lang-xtend">Object.toString(),</code></li>
								<li>a constructor accepting values for all fields in the declared order.</li>
							</ul>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="_1" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Parsing The Data</h2>
						<p>
							Let us now add another class to the same file and initialize a field
							called movies with a list of movies. For the initialization we parse the text file and turn the data records into <code class="prettyprint lang-xtend">Movie</code>s:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
import java.io.FileReader
import java.util.Set
import static extension com.google.common.io.CharStreams.*

class Movies {
  
  val movies = new FileReader('data.csv').readLines.map [ line |
    val segments = line.split('  ').iterator
    return new Movie(
      segments.next, 
      Integer.parseInt(segments.next), 
      Double.parseDouble(segments.next), 
      Long.parseLong(segments.next), 
      segments.toSet
    )
  ]
}</pre>
							<p>
						</p>
						<p>
							A <a href="#fields">field's type</a> can be inferred from the expression on the right hand-side. 
							That is called local type inference and is supported everywhere in Xtend.
							We want the field to be final, so we declare it as a value using the keyword <code class="prettyprint lang-xtend">val</code>.
						</p>
						<p>
							The initialization on the right hand side first creates a new <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/io/FileReader.html"><abbr title="java.io.FileReader">FileReader</abbr></a>.
							Then the method <code class="prettyprint lang-xtend">readLines()</code> is invoked on that instance. But if you have a look at <code class="prettyprint lang-xtend">FileReader</code> you will not find
							such a method. In fact <code class="prettyprint lang-xtend">readLines()</code> is a static method from Google Guava's <a href="http://guava-libraries.googlecode.com/svn/tags/release09/javadoc/com/google/common/io/CharStreams.html"><abbr title="com.google.common.io.CharStreams">CharStreams</abbr></a> which was imported 
							as an <a href="#extensionImports">extension</a>. Extensions allow us to use this readable syntax.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
import static extension com.google.common.io.CharStreams.*</pre>
							<p>
						</p>
						<p>
							<a href="http://guava-libraries.googlecode.com/svn/tags/release09/javadoc/com/google/common/io/CharStreams.html"><code class="prettyprint lang-xtend">CharStreams.readLines(Reader)</code></a> returns a <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/List.html"><code class="prettyprint lang-xtend">List&lt;String&gt;</code></a> on 
							which we call another extension method <code class="prettyprint lang-xtend">map</code>.
							This one is defined in the runtime library (<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/ListExtensions.html">ListExtensions.map(...)</a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/ListExtensions.java">(src)</a>) and is automatically imported and
							therefore available on all lists. The <code class="prettyprint lang-xtend">map</code> extension expects a function as a parameter.
							It basically invokes that function for each value in the list and returns another list containing the results of the function invocations. Actually
							this mapping is performed lazily so if you never access the values of the result list, the mapping function is never executed.
						</p>
						<p>
							Function objects are created using <a href="#lambdas">lambda expressions</a> (the code in squared brackets).
							Within the lambda we process a single line from the text file and turn it into a movie by splitting the string using 
							two whitespace characters as the separator. On the result of the split operation, the method <code class="prettyprint lang-xtend">iterator()</code> is invoked. 
							As you might know <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html">String.split(String)</a>
							returns a string array (<code class="prettyprint lang-xtend">String[]</code>), which Xtend <a href="#conversionRules">auto-converts to a list</a> when we 
							call <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Iterable.html"><code class="prettyprint lang-xtend">Iterable.iterator()</code></a> on it.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val segments = line.split('  ').iterator</pre>
							<p>
						</p>
						<p>
							Now we use the iterator to create an instance of <code class="prettyprint lang-xtend">Movie</code> for each String that it yields.
							The data type conversion (e.g. <code class="prettyprint lang-xtend">String</code> to <code class="prettyprint lang-xtend">int</code>) is done by calling <a href="#staticAccess">static methods</a> from the wrapper types. 
							The rest of the <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Iterable.html"><abbr title="java.lang.Iterable">Iterable</abbr></a> is turned into a set of categories. Therefore, the extension method 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/IteratorExtensions.html"><code class="prettyprint lang-xtend">IteratorExtensions.toSet(Iterator&lt;T&gt;)</code></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/IteratorExtensions.java">(src)</a>
							is invoked on the iterator to consume its remaining values.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
return new Movie (
  segments.next, 
  Integer.parseInt(segments.next), 
  Double.parseDouble(segments.next), 
  Long.parseLong(segments.next), 
  segments.toSet
)</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="_2" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Answering Some Questions</h2>
						<p>
							Now that we have parsed the text file into a <code class="prettyprint lang-xtend">List&lt;Movie&gt;</code>, we are ready to execute some queries against it.
							We use <strong>JUnit</strong> to make the individual queries executable and to confirm their results.
						</p>
						<!-- subsection -->
						<section id="_4" style="padding-top: 68px; margin-top: -68px;">
						<h3>Question 1 : What Is The Number Of Action Movies?</h3>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Test def numberOfActionMovies() {
  assertEquals(828, 
    movies.filter[ categories.contains('Action') ].size)
}</pre>
							<p>
						</p>
						<p>
							First the movies are <code class="prettyprint lang-xtend">filter</code>ed. The lambda expression checks whether the current movie's categories contain 
							the entry <code class="prettyprint lang-xtend">'Action'</code>. Note that unlike the lambda we used to turn the lines in the file into movies, we 
							have not declared a parameter name this time. 
							We could have written 
							</p>
							<pre class="prettyprint lang-xtend linenums">
movies.filter[ movie | movie.categories.contains('Action') ].size</pre>
							<p>
							
							but since we left out the name and the vertical bar the variable is automatically named <code class="prettyprint lang-xtend">it</code>.
							<code class="prettyprint lang-xtend">it</code> is an <a href="#implicitVariables">implicit variable</a>. It's uses are similar to the implicit variable <code class="prettyprint lang-xtend">this</code>.
							We can write either
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
movies.filter[ it.categories.contains('Action') ].size</pre>
							<p>
							
							or even more compact 
							</p>
							<pre class="prettyprint lang-xtend linenums">
movies.filter[ categories.contains('Action') ].size</pre>
							<p>
						</p>
						<p>
							Eventually we call <code class="prettyprint lang-xtend">size</code> on the resulting iterable which is an extension method, too. It is defined in the utility class 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/IterableExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.IterableExtensions">IterableExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/IterableExtensions.java">(src)</a>.
						</p>
						</section>
						<!-- subsection -->
						<section id="_5" style="padding-top: 68px; margin-top: -68px;">
						<h3>Question 2 : What Is The Year The Best Movie From The 80's Was Released?</h3>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Test def void yearOfBestMovieFrom80s() {
  assertEquals(1989, 
    movies.filter[ (1980..1989).contains(year) ].sortBy[ rating ].last.year)
}</pre>
							<p>
						</p>
						<p>
							Here we <code class="prettyprint lang-xtend">filter</code> for all movies whose year is included in the range from 1980 to 1989 (the 80's).
							The <code class="prettyprint lang-xtend">..</code> operator is again an extension defined in <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/IntegerExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.IntegerExtensions">IntegerExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/IntegerExtensions.java">(src)</a> and returns an instance of <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/IntegerRange.html"><abbr title="org.eclipse.xtext.xbase.lib.IntegerRange">IntegerRange</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/IntegerRange.java">(src)</a>.
							Operator overloading is explained in <a href="#operators">section</a>.
						</p>
						<p>
							The resulting iterable is sorted (<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/IterableExtensions.html"><code class="prettyprint lang-xtend">IterableExtensions.sortBy</code></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/IterableExtensions.java">(src)</a>) by the <code class="prettyprint lang-xtend">rating</code> of the movies. 
							Since it is sorted in ascending order, we take the last movie from the list and return its <code class="prettyprint lang-xtend">year</code>.
						</p>
						<p>
							We could have sorted descending and take the head of the list as well:
							</p>
							<pre class="prettyprint lang-xtend linenums">
movies.filter[ (1980..1989).contains(year) ].sortBy[ -rating ].head.year</pre>
							<p>
						</p>
						<p>
							Another possible solution would be to reverse the order of the sorted list:
							</p>
							<pre class="prettyprint lang-xtend linenums">
movies.filter[ (1980..1989).contains(year) ].sortBy[ rating ].reverseView.head.year</pre>
							<p>
						</p>
						<p>
							Note that first sorting and then taking the last or first is slightly more expensive than needed. We could
							have used the method <code class="prettyprint lang-xtend">reduce</code> instead to find the best movie which would be more efficient. Maybe
							you want to try it on your own?
						</p>
						<p>
							The calls to <code class="prettyprint lang-xtend">movie.year</code> as well as <code class="prettyprint lang-xtend">movie.categories</code> in the previous example in fact access the corresponding 
							<a href="#propertyAccess">getter methods</a>.
						</p>
						</section>
						<!-- subsection -->
						<section id="_6" style="padding-top: 68px; margin-top: -68px;">
						<h3>Question 3 : What Is The The Sum Of All Votes Of The Top Two Movies?</h3>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Test def void sumOfVotesOfTop2() {
  val long sum = movies.sortBy[ -rating ].take(2).map[ numberOfVotes ].reduce[ a, b | a + b ]
  assertEquals(47_229L, sum)
}</pre>
							<p>
						</p>
						<p>
							First the movies are sorted by rating, then we take the best two. Next the list of movies is turned into a list of their <code class="prettyprint lang-xtend">numberOfVotes</code> using the <code class="prettyprint lang-xtend">map</code> function. 
							Now we have a <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/List.html"><code class="prettyprint lang-xtend">List&lt;Long&gt;</code></a> which can be reduced to a single <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Long.html"><abbr title="java.lang.Long">Long</abbr></a> by adding the values.
						</p>
						<p>
							You could also use <code class="prettyprint lang-xtend">reduce</code> instead of <code class="prettyprint lang-xtend">map</code> and <code class="prettyprint lang-xtend">reduce</code>. Do you know how?
						</p>
						</section>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="types" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Java Interoperability
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							Xtend, like Java, is a statically typed language. In fact it completely supports Java's type system, including the primitive types 
							like <code class="prettyprint lang-xtend">int</code> or <code class="prettyprint lang-xtend">boolean</code>, arrays and all the Java classes, interfaces, enums and annotations that reside on the 
							class path.
						</p>
						<p>
							Java generics are fully supported as well: You can define type parameters on methods and classes and pass type arguments to
							generic types just as you are used to from Java. The type system and its conformance and casting rules are implemented as
							defined in  
							<a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/conversions.html">the Java Language Specification</a>.
						</p>
						<!--  section -->
						<section id="localTypeInference" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Type Inference</h2>
						<p>
							One of the problems with Java is that you are forced to write type signatures over
							and over again. That is why so many people do not like static typing. 
							But this is in fact not a problem of static typing but simply a problem with Java. Although Xtend is statically typed
							just like Java, you rarely have to write types down because they can be computed from the context.
						</p>
						</section>
						<!--  section -->
						<section id="conversionRules" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Conversion Rules</h2>
						<p>
							In addition to Java's autoboxing to convert primitives to their corresponding wrapper types (e.g. <code class="prettyprint lang-xtend">int</code>
							is automatically converted to <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Integer.html"><abbr title="java.lang.Integer">Integer</abbr></a> when needed), there are additional conversion rules in Xtend.
						</p>
						<p>
							Arrays are automatically converted to <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/List.html"><code class="prettyprint lang-xtend">List&lt;ComponentType&gt;</code></a> and vice versa. That is you can
							write the following:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def toList(String[] array) {
  val List&lt;String&gt; asList = array
  return asList
}</pre>
							<p>
						</p>
						<p>
							Subsequent changes to the array are reflected by the list and vice versa. Arrays of primitive types are converted to
							lists of their respective wrapper types.
						</p>
						<p>
							The conversion works the other way round, too. In fact, all subtypes of <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Iterable.html"><abbr title="java.lang.Iterable">Iterable</abbr></a> are automatically
							converted to arrays on demand.
						</p>
						<p>
							Another very useful conversion applies to lambda expressions. A lambda expression
							usually is of one of the types declared in <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/Functions.html"><abbr title="org.eclipse.xtext.xbase.lib.Functions">Functions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Functions.java">(src)</a>
							or <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/Procedures.html"><abbr title="org.eclipse.xtext.xbase.lib.Procedures">Procedures</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Procedures.java">(src)</a>. However, if the expected type is an interface or a class with a single 
							abstract method declaration, a lambda expression is automatically converted to that
							type. This allows to use lambda expressions with many existing Java libraries. See <a href="#closureTypes"></a>
							for more details.
						</p>
						</section>
						<!--  section -->
						<section id="javaInteroperability" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Interoperability with Java</h2>
						<p>
							Resembling and supporting every aspect of Java's type system ensures that there is no impedance mismatch between Java and Xtend.
							This means that Xtend and Java are 100% interoperable. There are no exceptional cases and you do not have
							to think in two worlds. You can invoke Xtend code from Java and vice versa without any surprises or hassles.
						</p>
						<p>
							As a bonus if you know Java's type system and are familiar with Java's generic types, you already know the most complicated part
							of Xtend.
						</p>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="Xtend_Classes_Members" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Classes and Members
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							At a first glance an Xtend file pretty much looks like a Java file. It starts with a package 
							declaration followed by an import section and class definitions.
							The classes in fact are directly translated to Java classes in the corresponding Java package.
							A class can have constructors, fields, methods and annotations.
						</p>
						<p>
							Here is an examplary Xtend file:
							</p>
							<pre class="prettyprint lang-xtend linenums">
package com.acme

import java.util.List

class MyClass {
  String name
  
  new(String name) {
    this.name = name
  }
  
  def String first(List&lt;String&gt; elements) {
    elements.get(0)
  }
}</pre>
							<p>
						</p>
						<!--  section -->
						<section id="packageDecl" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Package Declaration</h2>
						<p>
							Package declarations can look like those in Java. Two small, optional differences:
							</p>
							<ul>
								<li>An identifier can be escaped with a <code class="prettyprint lang-xtend">^</code> character in case it conflicts with a keyword.</li>
								<li>The terminating semicolon is optional.</li>
							</ul>
							<p>
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
package com.acme</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="imports" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Imports</h2>
						<p>
							The ordinary imports of type names are equivalent to the imports known from Java. 
							Again one can escape any names conflicting with keywords using a <code class="prettyprint lang-xtend">^</code>. In contrast to Java, the 
							terminating semicolon is optional. Non-static wildcard type imports are deprecated for the benefit of better usability and well
							defined dependencies.
						</p>
						<p>
							Xtend also features static imports for importing static fields and methods. The semantics and syntax are just like in Java.
						</p>
						<p>
							As in Java all classes from the <code class="prettyprint lang-xtend">java.lang</code> package are implicitly imported.
							</p>
							<pre class="prettyprint lang-xtend linenums">
import java.math.BigDecimal
import static java.util.Collections.sort
import static org.junit.Assert.*</pre>
							<p>
						</p>
						<p>
							Static methods can also be imported as <code class="prettyprint lang-xtend">extension</code>s. See the section on 
							<a href="#extensionMethods">extension methods</a> for details.
						</p>
						</section>
						<!--  section -->
						<section id="Xtend_ClassDeclaration" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Class Declaration</h2>
						<p>
							The class declaration reuses a lot of Java's syntax but still is a bit different in some aspects:
							All Xtend types are <code class="prettyprint lang-xtend">public</code> by default since that's the common case. Java's "package private" 
							default visibility is declared by the more explicit keyword <code class="prettyprint lang-xtend">package</code> in Xtend. In contrast to Java,
							Xtend supports multiple public top level class declarations per file. Each Xtend class
							is compiled to a separate top-level Java class.
						</p>
						<p>
							Abstract classes are defined using the <code class="prettyprint lang-xtend">abstract</code> modifier as in Java. See also <a href="#abstractMethods">abstract methods</a>.
						</p>
						<p>
							Xtend's approach to inheritance is conceptually the same as in Java. Single inheritance of 
							classes as well as implementing multiple interfaces is supported. 
							Xtend classes can extend other Xtend classes, and even Java classes can inherit from Xtend classes.
							If no super type is specified, <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html"><abbr title="java.lang.Object">Object</abbr></a> is used.
						</p>
						<p>
							The most simple class looks like this:
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MyClass {
}</pre>
							<p>
						</p>
						<p>
							A more advanced generic class declaration in Xtend:
							</p>
							<pre class="prettyprint lang-xtend linenums">
class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, 
                   Cloneable, java.io.Serializable {
  ...
}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="constructors" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Constructors</h2>
						<p>
							An Xtend class can define any number of constructors. Unlike Java you do not have to repeat the name of the class over and over again,
							but use the keyword <code class="prettyprint lang-xtend">new</code> to declare a constructor.
							Constructors can also delegate to other constructors using <code class="prettyprint lang-xtend">this(args...)</code> in their first
							line. 
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MyClass extends AnotherClass {
  new(String s) {
    super(s)
  }
  
  new() {
    this("default")
  }
}</pre>
							<p>
						</p>
						<p>
							The same rules with regard to inheritance apply as in Java, i.e. if the super class does not define a 
							no-argument constructor, you have to explicitly call one using <code class="prettyprint lang-xtend">super(args...)</code> as the first 
							expression in the body of the constructor.
						</p>
						<p>
							The default visibility of constructors is <code class="prettyprint lang-xtend">public</code> but you can also specify an explicit visiblity 
							<code class="prettyprint lang-xtend">public</code>, <code class="prettyprint lang-xtend">protected</code>, <code class="prettyprint lang-xtend">package</code> or <code class="prettyprint lang-xtend">private</code>.
						</p>
						</section>
						<!--  section -->
						<section id="fields" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Fields</h2>
						<p>
							A field can have an initializer. Final fields are declared using <code class="prettyprint lang-xtend">val</code>, while 
							<code class="prettyprint lang-xtend">var</code> introduces a non-final field and can be omitted. Yet, if an initializer expression
							is present, the type of a field can be inferred if <code class="prettyprint lang-xtend">val</code> or <code class="prettyprint lang-xtend">var</code> was
							used to introduce the field. The keyword <code class="prettyprint lang-xtend">final</code> is synonym to <code class="prettyprint lang-xtend">val</code>.
							Fields marked as <code class="prettyprint lang-xtend">static</code> will be compiled to static Java fields.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MyClass {
  int count = 1
  static boolean debug = false
  var name = 'Foo'          // type String is inferred 
  val UNIVERSAL_ANSWER = 42 // final field with inferred type int
  ...
}</pre>
							<p>
						</p>
						<p>
							The default visibility for fields is <code class="prettyprint lang-xtend">private</code>. You can also declare it explicitly as 
							being <code class="prettyprint lang-xtend">public</code>, <code class="prettyprint lang-xtend">protected</code>, <code class="prettyprint lang-xtend">package</code> or <code class="prettyprint lang-xtend">private</code>.
						</p>
						<p>
							A specialty of Xtend are fields that provide <strong>extension methods</strong> which are covered in 
							<a href="#extensionMethods">their own section</a>.
						</p>
						</section>
						<!--  section -->
						<section id="methods" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Methods</h2>
						<p>
							Xtend methods are declared within a class and are translated to a corresponding Java method with 
							exactly the same signature. The only exceptions are dispatch methods, which are explained 
							<a href="#polymorphicDispatch">later</a>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def String first(List&lt;String&gt; elements) {
  elements.get(0)
}</pre>
							<p>
						</p>
						<p>
							Method declarations start with the keyword <code class="prettyprint lang-xtend">def</code>.
							The default visibility of a method is <code class="prettyprint lang-xtend">public</code>. You can explicitly declare it as
							being <code class="prettyprint lang-xtend">public</code>, <code class="prettyprint lang-xtend">protected</code>, <code class="prettyprint lang-xtend">package</code> or <code class="prettyprint lang-xtend">private</code>.
						</p>
						<p>
							Xtend supports the <code class="prettyprint lang-xtend">static</code> modifier for methods and can <a href="#inferredReturnTypes">infer</a> the return type if it is not explicitly given:
							</p>
							<pre class="prettyprint lang-xtend linenums">
def static createInstance() {
  new MyClass('foo')
}</pre>
							<p>
						</p>
						<p>
							As in Java, vararg parameters are allowed and accessible as array values in the method body:
							</p>
							<pre class="prettyprint lang-xtend linenums">
def printAll(String... strings) {
  strings.forEach[ s | println(s) ]
}</pre>
							<p>
						</p>
						<p>
							It is possible to infer the return type of a method from its body. Recursive methods and abstract
							methods have to declare an explicit return type.
						</p>
						<!-- subsection -->
						<section id="abstractMethods" style="padding-top: 68px; margin-top: -68px;">
						<h3>Abstract Methods</h3>
						<p>
							An abstract method in Xtend does not define a body and must be declared within an <code class="prettyprint lang-xtend">abstract</code>
							class or an interface. Also specifying the return type is mandatory since it cannot be inferred.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
abstract class MyAbstractClass() {
  def String abstractMethod() // no body
}</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="_7" style="padding-top: 68px; margin-top: -68px;">
						<h3>Overriding Methods</h3>
						<p>
							Methods can override other methods from the super class or implement interface methods using the
							keyword <code class="prettyprint lang-xtend">override</code>. If a method overrides a method from a super type, the 
							<code class="prettyprint lang-xtend">override</code> keyword is mandatory and replaces the keyword <code class="prettyprint lang-xtend">def</code>. The override semantics
							are the same as in Java, e.g. it is impossible to override <code class="prettyprint lang-java">final</code> methods or invisible methods.
							Overriding methods inherit their return type from the super declaration.
						</p>
						<p>
							Example:
							</p>
							<pre class="prettyprint lang-xtend linenums">
override String second(List&lt;String&gt; elements) {
  elements.get(1)
}</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="declaredExceptions" style="padding-top: 68px; margin-top: -68px;">
						<h3>Declared Exceptions</h3>
						<p>
							Xtend does not force you to catch or declare checked exceptions. Nevertheless, you can still declare 
							the exceptions thrown in a method's body using the <code class="prettyprint lang-xtend">throws</code> clause as in Java.
						</p>
						<p>
							If you do not declare checked exceptions in your method but they are possibly thrown in your code, the
							compiler will throw the checked exception silently (using the sneaky-throw technique introduced by 
							<a href="http://projectlombok.org/features/SneakyThrows.html">Lombok</a>). 
							  
							</p>
							<pre class="prettyprint lang-xtend linenums">
/*
 * throws an Exception
 */
def void throwException() throws Exception {
   throw new Exception
}

/*
 * throws an Exception without declaring it
 */
def void sneakyThrowException() {
   throw new Exception
}</pre>
							<p>
						</p>
						<p>
							Optional validation of checked exception is supported, too, and can be configured on the respective Eclipse
							preference page for the Xtend Errors and Warnings.
						</p>
						</section>
						<!-- subsection -->
						<section id="inferredReturnTypes" style="padding-top: 68px; margin-top: -68px;">
						<h3>Inferred Return Types</h3>
						<p>
							If the return type of a method can be inferred from its body it does not have to be declared.
						</p>
						<p>
							That is the method
							</p>
							<pre class="prettyprint lang-xtend linenums">
def String second(List&lt;String&gt; elements) {
  elements.get(1)
}</pre>
							<p>
						</p>
						<p>
							could be declared like this:
							</p>
							<pre class="prettyprint lang-xtend linenums">
def second(List&lt;String&gt; elements) {
  elements.get(1)
}</pre>
							<p>
						</p>
						<p>
							The return type is mandatory for abstract method declarations as well as for recursive implementations.
						</p>
						</section>
						<!-- subsection -->
						<section id="genericMethods" style="padding-top: 68px; margin-top: -68px;">
						<h3>Generic Methods</h3>
						<p>
							You can specify type parameters on methods. A parameterized variant of the method from the previous section,
							could look like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def &lt;T&gt; second(List&lt;T&gt; elements) {
  elements.get(1)
}</pre>
							<p>
						</p>
						<p>
							Type parameter bounds and constraints are supported and share the same syntax and semantics as defined in the 
							<a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/classes.html#8.4.4">the Java Language Specification</a>
						</p>
						</section>
						<!-- subsection -->
						<section id="operatorDeclaration" style="padding-top: 68px; margin-top: -68px;">
						<h3>Operator Declarations</h3>
						<p>
							Xtend support operator overloading based on an operator-name-mapping as explained in <a href="#operators"></a>.
							To declare an operator one can either declare a simple method using the operator's name or the operator directly like in the
							following:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class Money {
											def + (Money other) { ... }
											def - (Money other) { ... }
											def * (BigDecimal times) { ... }
											...
}</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="polymorphicDispatch" style="padding-top: 68px; margin-top: -68px;">
						<h3>Dispatch Methods</h3>
						<p>
							Generally, method resolution and binding is done statically at compile time as in Java. Method calls are bound 
							based on the static types of arguments. Sometimes this is not what you want. Especially in the 
							context of <a href="#extensionMethods">extension methods</a> you would like to have polymorphic behavior.
						</p>
						<p>
							A dispatch method is declared using the keyword <code class="prettyprint lang-xtend">dispatch</code>.
							</p>
							<pre class="prettyprint lang-xtend linenums">
def dispatch printType(Number x) { 
  "it's a number" 
}

def dispatch printType(Integer x) { 
  "it's an int" 
}</pre>
							<p>
						</p>
						<p>
							For a set of visible dispatch methods in the current type hierarchy with the same name and the same
							number of arguments, the compiler infers a synthetic dispatcher method. This dispatcher uses the common super type
							of all declared arguments. The method name of the actual dispatch cases is prepended with an underscore
							and the visibility of these methods is reduced to protected if they have been defined as public methods.
							Client code always binds to the synthesized dispatcher method.
						</p>
						<p>
							For the two dispatch methods in the example above the following Java code would be generated:
							</p>
							<pre class="prettyprint lang-java linenums">
protected String _printType(final Number x) {
  return "it\'s a number";
}

protected String _printType(final Integer x) {
  return "it\'s an int";
}

public String printType(final Number x) {
  if (x instanceof Integer) {
    return _printType((Integer)x);
  } else if (x != null) {
    return _printType(x);
  } else {
    throw new IllegalArgumentException("Unhandled parameter types: " +
      Arrays.&lt;Object&gt;asList(x).toString());
  }
}</pre>
							<p>
						</p>
						<p>
							Note that the <code class="prettyprint lang-java">instanceof</code> cascade is ordered such that more specific types are handled first.
						</p>
						<p>
							The default visibility of the dispatch cases is <code class="prettyprint lang-xtend">protected</code>. If all dispatch methods
							explicitly declare the same visibility, this will be the visibility of the inferred dispatcher, too.
							Otherwise it is <code class="prettyprint lang-xtend">public</code>.
							 
							The comparison of the parameter types is performed from left to right. That is in the following example, the second
							method declaration is considered more specific since its first parameter type is the most specific:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def dispatch printTypes(Number x, Integer y) { 
  "it's some number and an int" 
}

def dispatch printTypes(Integer x, Number y) { 
  "it's an int and a number" 
}</pre>
							<p>
						</p>
						<p>
							generates the following Java code :
							</p>
							<pre class="prettyprint lang-java linenums">
public String printTypes(final Number x, final Number y) {
  if (x instanceof Integer
       &amp;&amp; y != null) {
    return _printTypes((Integer)x, y);
  } else if (x != null
       &amp;&amp; y instanceof Integer) {
    return _printTypes(x, (Integer)y);
  } else {
    throw new IllegalArgumentException("Unhandled parameter types: " +
      Arrays.&lt;Object&gt;asList(x, y).toString());
  }
}</pre>
							<p>
						</p>
						<p>
							The code is compiled in a way that a <code class="prettyprint lang-xtend">null</code> reference is never a match. <code class="prettyprint lang-xtend">null</code> values 
							can be handled by dispatch cases that use the parameter type <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Void.html"><abbr title="java.lang.Void">Void</abbr></a>.
							</p>
							<pre class="prettyprint lang-xtend linenums">
def dispatch printType(Number x) { 
  "it's some number" 
}

def dispatch printType(Integer x) { 
  "it's an int" 
}

def dispatch printType(Void x) { 
  "it's null" 
}</pre>
							<p>
						</p>
						<p>
							This compiles to the following Java code:
							</p>
							<pre class="prettyprint lang-java linenums">
public String printType(final Number x) {
  if (x instanceof Integer) {
    return _printType((Integer)x);
  } else if (x != null) {
    return _printType(x);
  } else if (x == null) {
    return _printType((Void)null);
  } else {
    throw new IllegalArgumentException("Unhandled parameter types: " +
      Arrays.&lt;Object&gt;asList(x).toString());
  }
}</pre>
							<p>
						</p>
						<!-- subsection -->
						<section id="_8" style="padding-top: 68px; margin-top: -68px;">
						<h4>Dispatch Methods and Inheritance</h4>
						<p>
							All visible Java methods from all super types that are conformant to the compiled representation of 
							a dispatch method are also included in the dispatcher. Conforming means they have the expected number of arguments 
							and have the same compiled name with the prepended underscore.
						</p>
						<p>
							For example, consider the following Java class :
							</p>
							<pre class="prettyprint lang-java linenums">
public abstract class AbstractLabelProvider {
   protected String _label(Object o) {
      // some generic implementation
   }
}</pre>
							<p>
						</p>
						<p>
							and the following Xtend class which extends the Java class :
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MyLabelProvider extends AbstractLabelProvider {
   def dispatch label(Entity it)  {
     name
   }
     
   def dispatch label(Method it) { 
     name+"("+params.join(",")+"):"+type
   }
   
   def dispatch label(Field it) { 
     name+type
   }
}</pre>
							<p>
						</p>
						<p>
							The resulting dispatch method in the generated Java class <code class="prettyprint lang-xtend">MyLabelProvider</code> would then look like this:
							</p>
							<pre class="prettyprint lang-java linenums">
public String label(final Object it) {
  if (it instanceof Entity) {
    return _label((Entity)it);
  } else if (it instanceof Field) {
    return _label((Field)it);
  } else if (it instanceof Method) {
    return _label((Method)it);
  } else if (it != null) {
    return super._label(it);
  } else {
    throw new IllegalArgumentException("Unhandled parameter types: " +
      Arrays.&lt;Object&gt;asList(it).toString());
  }
}</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="_9" style="padding-top: 68px; margin-top: -68px;">
						<h4>Static Dispatch Methods</h4>
						<p>
							Also static dispatch methods are supported. A mixture of static and non-static
							dispatch methods is prohibited.
						</p>
						</section>
						</section>
						</section>
						<!--  section -->
						<section id="Annotations" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Annotations</h2>
						<p>
							Annotations are available on classes, fields, methods and parameters. They are prefixed
							with the <code class="prettyprint lang-xtend">@</code> character and accept a number of key-value pairs or a default value
							for the annotation property named <code class="prettyprint lang-xtend">value</code>. Annotation
							values that expect arrays can handle single values, too. Value arrays are enclosed in array 
							literals <code class="prettyprint lang-xtend">#['first', 'second']</code>.
							The semantics for annotations are exactly like defined in the 
							<a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/j3TOC.html">Java Language Specification</a>. 
							Here is an example:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@TypeAnnotation("some value")
class MyClass {
  @FieldAnnotation(value = @NestedAnnotation(true))
  static val CONSTANT = 'a compile-time constant'
  
  @MethodAnnotation(constant = CONSTANT)
  def String myMethod(@ParameterAnnotation String param) {
    //...
  }
}</pre>
							<p>
						</p>
						<p>
							In addition <a href="#activeAnnotations">Active Annotations</a> allow users to participate in compilation of
							Xtend code to Java source code.
						</p>
						</section>
						<!--  section -->
						<section id="extensionMethods" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Extension Methods</h2>
						<p>
							Extension methods allow to add new methods to existing types without modifying them. 
							This feature is actually where Xtend got its name from. They are based on a simple syntactic trick: 
							Instead of passing the first argument of an extension method inside the parentheses of a method invocation, the 
							method can be called with the first argument as its receiver - it can be called as if the method was one of the argument type's members.
							</p>
							<pre class="prettyprint lang-xtend linenums">
"hello".toFirstUpper() // calls StringExtensions.toFirstUpper("hello")</pre>
							<p>
						</p>
						<p>
							Method calls in extension syntax often result in more readable code, as they are chained rather than nested. 
							Another benefit of extensions is that you can add methods which are specific to a certain context
							or layer of your application.
						</p>
						<p>
							For instance, you might not want to put UI-specific methods and dependencies into your
							domain model classes. Therefore this functionality is often defined in static methods or methods in
							utility classes or service layers. That works, but the code is less readable and less object-oriented if you call methods
							like this. In Java you often see code like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
persistenceManager.save(myObject);</pre>
							<p>
						</p>
						<p>
							Without tying your entities to the persistenceManager, extension methods allow you to write
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
myObject.save</pre>
							<p>
						</p>
						<p>
							There are different ways to make methods available as extensions, which are described in the following sections.
						</p>
						<!-- subsection -->
						<section id="libraryExtensions" style="padding-top: 68px; margin-top: -68px;">
						<h3>Extensions from the Library</h3>
						<p>
							The Xtend library puts a lot of very useful extension methods on existing types from the Java
							SDK without any further ado.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
"hello".toFirstUpper // calls StringExtensions.toFirstUpper(String)
listOfStrings.map[ toUpperCase ] // calls ListExtensions.&lt;T, R&gt;map(List&lt;T&gt; list, Function&lt;? super T, ? extends R&gt; mapFunction)</pre>
							<p>
						</p>
						<p>
							Have a look at the JavaDoc to learn about the available functionality:
						</p>
						<p>
							</p>
							<ul>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/ObjectExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.ObjectExtensions">ObjectExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/ObjectExtensions.java">(src)</a></li>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/IterableExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.IterableExtensions">IterableExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/IterableExtensions.java">(src)</a></li>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/MapExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.MapExtensions">MapExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/MapExtensions.java">(src)</a></li>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/ListExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.ListExtensions">ListExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/ListExtensions.java">(src)</a></li>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/CollectionExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.CollectionExtensions">CollectionExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/CollectionExtensions.java">(src)</a></li>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/BooleanExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.BooleanExtensions">BooleanExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/BooleanExtensions.java">(src)</a></li>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/IntegerExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.IntegerExtensions">IntegerExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/IntegerExtensions.java">(src)</a></li>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/FunctionExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.FunctionExtensions">FunctionExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/FunctionExtensions.java">(src)</a></li>
							</ul>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="_10" style="padding-top: 68px; margin-top: -68px;">
						<h3>Local Extension Methods</h3>
						<p>
							All visible non-static methods of the current class and its super types are automatically available as extensions. For example
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MyClass {
  def doSomething(Object obj) {
    // do something with obj
  }
  
  def extensionCall(Object obj) {
    obj.doSomething()  // calls this.doSomething(obj)
  }
}</pre>
							<p>
						</p>
						<p>
							Local static methods have to be made available through an import like any other static method.
						</p>
						</section>
						<!-- subsection -->
						<section id="extensionImports" style="padding-top: 68px; margin-top: -68px;">
						<h3>Extension Imports</h3>
						<p>
							In Java, you would usually write a helper class with static methods to decorate an existing
							class with additional behavior. In order to integrate such static helper classes, Xtend allows to put
							the keyword <code class="prettyprint lang-xtend">extension</code> after the <code class="prettyprint lang-xtend">static</code> keyword of a <a href="#imports">static import</a>
							thus making all imported static functions available as extensions methods.
						</p>
						<p>
							The following import declaration 
							</p>
							<pre class="prettyprint lang-xtend linenums">
import static extension java.util.Collections.singletonList</pre>
							<p>
						</p>
						<p>
							allows us to use singletonList methods like this:
							</p>
							<pre class="prettyprint lang-xtend linenums">
new MyClass().singletonList() 
// calls Collections.singletonList(new MyClass())</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="Extension_Provider" style="padding-top: 68px; margin-top: -68px;">
						<h3>Extension Provider</h3>
						<p>
							By adding the <code class="prettyprint lang-xtend">extension</code> keyword to a field, a local variable or a parameter
							declaration, its instance methods become extension methods.
						</p>
						<p>
							Imagine you want to have some layer specific functionality on a class <code class="prettyprint lang-xtend">Person</code>. Let us say you are in a servlet-like class
							and want to persist a <code class="prettyprint lang-xtend">Person</code> using some persistence mechanism. Let us assume <code class="prettyprint lang-xtend">Person</code> implements
							a common interface <code class="prettyprint lang-xtend">Entity</code>.
							 
							You could have the following interface
							</p>
							<pre class="prettyprint lang-java linenums">
interface EntityPersistence {
  public save(Entity e);
  public update(Entity e);
  public delete(Entity e);
}</pre>
							<p>
						</p>
						<p>
							And if you have obtained an instance of that type (through a factory or dependency injection or what ever) like this:
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MyServlet {
  extension EntityPersistence ep = Factory.get(EntityPersistence)
  ...
  
}</pre>
							<p>
						</p>
						<p>
							You are able to save, update and delete any entity like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val Person person = ...
person.save  // calls ep.save(person)
person.name = 'Horst'
person.update  // calls ep.update(person)
person.delete  // calls ep.delete(person)</pre>
							<p>
						</p>
						<p>
							Using the <code class="prettyprint lang-xtend">extension</code> modifier on values has a significant advantage over 
							static <a href="#extensionImports">extension imports</a>: Your code is not bound to the actual implementation of the extension method.
							You can simply exchange the component that provides the referenced extension with another implementation from outside,
							by providing a different instance.
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="interfaces" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Interface Declaration</h2>
						<p>
							An interface declaration is very similar to the one in Java. An interface can declare fields, which are
							by default final static therefore must have an initial value. And of course methods can
							be declared. They are public by default. Interfaces can extend any number of other interfaces and can
							declare type parameters.
						</p>
						<p>
							Here's an example:
							</p>
							<pre class="prettyprint lang-xtend linenums">
interface MyInterface&lt;T&gt; extends OtherInterface {
  val CONSTANT = 42
  def T doStuff(String ... varArg) throws SomeException
}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="annotationTypeDeclaration" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Annotation Type Declaration</h2>
						<p>
							Annotation types can also be declared. The are introduced by the keyword <code class="prettyprint lang-xtend">annotation</code> and declare their values
							with a concise syntax:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
annotation MyAnnotation {
  String[] value
  boolean isTricky = false
  int[] lotteryNumbers = #[ 42, 137 ]
}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="enumTypeDeclaration" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Enum Type Declaration</h2>
						<p>
							Enumeration types are declared like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
enum MyColor {
  GREEN,
  BLUE,
  RED
}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="Nested_Type_Declarations" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Nested Type Declarations</h2>
						<p>
							Classes, enum, annotation and interface declarations can be nested. Just as in Java nested enums, annotations and interfaces are always static.
							In Xtend nested classes are also always static. Nested types are public by default and can only be nethed within class, interface and annotation declarations.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MyClass {
  static class NestedClass {}
  annotation NestedAnnotation {}
  enum NestedEnum {}
  interface NestedInterface {}
}

interface MyInterface {
  static class NestedClass {}
  annotation NestedAnnotation {}
  enum NestedEnum {}
  interface NestedInterface {}
}

annotation MyAnnotation {
  static class NestedClass {}
  annotation NestedAnnotation {}
  enum NestedEnum {}
  interface NestedInterface {}
}</pre>
							<p>
						</p>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="Xtend_Expressions" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Expressions
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							In Xtend everything is an expression and has a return type. Statements do not exist. 
							That allows you to compose your code in interesting ways. For example, you can have a
							<code class="prettyprint lang-xtend">try catch</code> expression on the right hand side of an assignment: 
							</p>
							<pre class="prettyprint lang-xtend linenums">
val data = try {
    fileContentsToString('data.txt')
  } catch (IOException e) {
    'dummy data'
  }</pre>
							<p>
						</p>
						<p>
							If <code class="prettyprint lang-xtend">fileContentsToString()</code> throws an <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/io/IOException.html"><abbr title="java.io.IOException">IOException</abbr></a>, it is caught and the string <code class="prettyprint lang-xtend">'dummy data'</code> is assigned to the value <code class="prettyprint lang-xtend">data</code>.
							 
							Expressions can appear as <a href="#fields">initializers of fields</a>, the body of constructors
							or methods and as values in annotations. A method body can either be a <a href="#blocks">block expression</a> 
							or a <a href="#templates">template expression</a>.
						</p>
						<!--  section -->
						<section id="Xtend_Expressions_Literals" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Literals</h2>
						<p>
							A literal denotes a fixed, unchangeable value. Literals for <a href="#stringLiterals">strings</a>, <a href="#numberLiterals">numbers</a>, <a href="#booleanLiteral">booleans</a>,
							<code class="prettyprint lang-xtend">null</code> and <a href="#typeLiteral">Java types</a> are supported as well as literals for unmodifiable collection types like lists,
							sets and maps or literals for arrays.
						</p>
						<!-- subsection -->
						<section id="stringLiterals" style="padding-top: 68px; margin-top: -68px;">
						<h3>String Literals</h3>
						<p>
							A string literal is of type <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html"><abbr title="java.lang.String">String</abbr></a>.
							String literals are enclosed in a pair of single quotes or double quotes. Single quotes are more common
							because the signal-to-noise ration is better, but generally you should use the terminals which are
							least likely to occur in the string value. Special characters can be quoted with a backslash or defined using
							unicode notation. Contrary to Java, strings can span multiple lines.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
'Hello World !'
"Hello World !"
'Hello "World" !'
"Hello \"World\" !"
"Hello 

  World !"</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="characterLiterals" style="padding-top: 68px; margin-top: -68px;">
						<h3>Character Literals</h3>
						<p>
							Character literals use the same notation as String literals. If a single character literal is used in a context where a primitive <code class="prettyprint lang-xtend">char</code> or
							the wrapper type <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Character.html"><abbr title="java.lang.Character">Character</abbr></a> is expected, the compiler will treat the literal as such a value or instance.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val char c = 'c'</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="numberLiterals" style="padding-top: 68px; margin-top: -68px;">
						<h3>Number Literals</h3>
						<p>
							Xtend supports roughly the same number literals as Java with a few differences.   
							First, there are no signed number literals. If you put a minus operator in front of a number 
							literal it is treated as a <a href="#operators">unary operator</a> with one argument (the positive number 
							literal). Second, as in Java 7, you can separate digits using <code class="prettyprint lang-xtend">_</code> for better readability
							of large numbers.
							 
							An integer literal creates an <code class="prettyprint lang-xtend">int</code>, a <code class="prettyprint lang-xtend">long</code> (suffix <code class="prettyprint lang-xtend">L</code>) or a
							<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/math/BigInteger.html"><abbr title="java.math.BigInteger">BigInteger</abbr></a> (suffix <code class="prettyprint lang-xtend">BI</code>). There are no octal numbers
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
42
1_234_567_890 
0xbeef    // hexadecimal
077       // decimal 77 (*NOT* octal)
-1  // an expression consisting of the unary - operator and an integer literal  
42L
0xbeef#L // hexadecimal, mind the '#'
0xbeef_beef_beef_beef_beef#BI // BigInteger</pre>
							<p>
						</p>
						<p>
							A floating-point literal creates a <code class="prettyprint lang-xtend">double</code> (suffix <code class="prettyprint lang-xtend">D</code> or none), a <code class="prettyprint lang-xtend">float</code> 
							(suffix <code class="prettyprint lang-xtend">F</code>) or a <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/math/BigDecimal.html"><abbr title="java.math.BigDecimal">BigDecimal</abbr></a> (suffix <code class="prettyprint lang-xtend">BD</code>). If you use a <code class="prettyprint lang-xtend">.</code> you have to 
							specify both, the integral and the fractional part of the mantissa. There are only decimal floating-point 
							literals.  
							</p>
							<pre class="prettyprint lang-xtend linenums">
42d     // double
0.42e2  // implicit double
0.42e2f // float
4.2f    // float
0.123_456_789_123_456_789_123_456_789e2000bd // BigDecimal</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="booleanLiteral" style="padding-top: 68px; margin-top: -68px;">
						<h3>Boolean Literals</h3>
						<p>
							There are two boolean literals, <code class="prettyprint lang-xtend">true</code> and <code class="prettyprint lang-xtend">false</code> which correspond to their 
							Java counterpart of type <code class="prettyprint lang-xtend">boolean</code>.
						</p>
						</section>
						<!-- subsection -->
						<section id="nullLiteral" style="padding-top: 68px; margin-top: -68px;">
						<h3>Null Literal</h3>
						<p>
							The null pointer literal <code class="prettyprint lang-xtend">null</code> has exactly the same semantics as in Java.
						</p>
						</section>
						<!-- subsection -->
						<section id="typeLiteral" style="padding-top: 68px; margin-top: -68px;">
						<h3>Type Literals</h3>
						<p>
							The syntax for type literals is generally the plain name of the type, e.g. the snippet <code class="prettyprint lang-xtend">String</code>
							is equivalent to the Java code <code class="prettyprint lang-java">String.class</code>. Nested types use the delimiter <code class="prettyprint lang-xtend">'.'</code>.
						</p>
						<p>
							To disambiguate the expression, type literals may also be specified using the keyword <code class="prettyprint lang-xtend">typeof</code>.
						</p>
						<p>
							</p>
							<ul>
								<li><code class="prettyprint lang-xtend">Map.Entry</code> is equivalent to <code class="prettyprint lang-java">Map.Entry.class</code></li>
								<li><code class="prettyprint lang-xtend">typeof(StringBuilder)</code> yields <code class="prettyprint lang-java">StringBuilder.class</code></li>
							</ul>
							<p>
						</p>
						<p>
							Consequently it is possible to access the members of a type reflectively by using its plain name <code class="prettyprint lang-xtend">String.getDeclaredFields</code>.
						</p>
						<p>
							The keyword <code class="prettyprint lang-xtend">typeof</code> is mandatory for references to array types, e.g. <code class="prettyprint lang-xtend">typeof(int[]</code>
						</p>
						<p>
							Previous versions of Xtend (2.4.1 and before) used the dollar as the delimiter character for nested types and
							enforced the use of <code class="prettyprint lang-xtend">typeof</code> for all type literals:
						</p>
						<p>
							</p>
							<ul>
								<li><code class="prettyprint lang-xtend">typeof(Map$Entry)</code> yields <code class="prettyprint lang-java">Map.Entry.class</code></li>
							</ul>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="collectionLiterals" style="padding-top: 68px; margin-top: -68px;">
						<h3>Collection Literals</h3>
						<p>
							The methods in <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/CollectionLiterals.html"><abbr title="org.eclipse.xtext.xbase.lib.CollectionLiterals">CollectionLiterals</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/CollectionLiterals.java">(src)</a> are automatically imported so
							it's very easy and convenient to create instances of the various collection types the JDK offers.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val myList = newArrayList('Hello', 'World')
val myMap = newLinkedHashMap('a' -&gt; 1, 'b' -&gt; 2)</pre>
							<p>
						</p>
						<p>
							In addition xtend supports collection literals to create immutable collections and arrays, depending on
							the target type. An immutable list can be created like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val myList = #['Hello','World']</pre>
							<p>
						</p>
						<p>
							If the target type is an array as in the following example an array is created instead without any
							conversion:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val String[] myArray = #['Hello','World']</pre>
							<p>
						</p>
						<p>
							An immutable set can be created using curly braces instead of the squared brackets:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val mySet = #{'Hello','World'}</pre>
							<p>
						</p>
						<p>
							An immutable map is created like this:
							 
							</p>
							<pre class="prettyprint lang-xtend linenums">
val myMap = #{'a' -&gt; 1 ,'b' -&gt;2}</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="arrays" style="padding-top: 68px; margin-top: -68px;">
						<h3>Arrays</h3>
						<p>
							Java arrays can be created either using a <a href="#collectionLiterals">literal</a> as described in the previous
							section, or if it should be a new array with a fixed size, one of the 
							methods from <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/ArrayLiterals.html"><abbr title="org.eclipse.xtext.xbase.lib.ArrayLiterals">ArrayLiterals</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/ArrayLiterals.java">(src)</a> can be used. The generic <code class="prettyprint lang-xtend">newArrayOfSize(int)</code>
							method works for all reference types, while there is a specific factory method for each primitive type.
						</p>
						<p>
							Example:
							</p>
							<pre class="prettyprint lang-xtend linenums">
val String[] myArray = newArrayOfSize(400)
val int[] intArray = newIntArrayOfSize(400)</pre>
							<p>
						</p>
						<p>
							Retrieving and setting values of arrays is done through the extension methods <code class="prettyprint lang-xtend">get(int)</code> and 
							<code class="prettyprint lang-xtend">set(int, T)</code> which are specifically overloaded for arrays and are translated directly to the
							equivalent native Java code <code class="prettyprint lang-xtend">myArray[int]</code>.
						</p>
						<p>
							Also <code class="prettyprint lang-xtend">length</code> is available as an extension method and is directly translated to Java's equivalent
							<code class="prettyprint lang-java">myArray.length</code>.
						</p>
						<p>
							Furthermore arrays are automatically converted to lists (<code class="prettyprint lang-xtend">java.util.List</code>) when needed. This works similar to how boxing and unboxing between
							primitives and their respective wrapper types work.
						</p>
						<p>
							Example:
							</p>
							<pre class="prettyprint lang-xtend linenums">
val int[] myArray = #[1,2,3]
val List&lt;Integer&gt; myList = myArray</pre>
							<p>
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="typeCasts" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Type Casts</h2>
						<p>
							A type cast behaves exactly like casts in Java, but has a slightly more readable syntax.
							Type casts bind stronger than any other operator but weaker than feature calls.
						</p>
						<p>
							The conformance rules for casts are defined in the 
							<a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/conversions.html#5.5">Java Language Specification</a>.
							Here are some examples:
							</p>
							<pre class="prettyprint lang-xtend linenums">
something as MyClass
42 as Integer</pre>
							<p>
						</p>
						<p>
							Instead of a plain type cast it's also possible to use a <a href="#switchExpression">switch with a type guard</a> 
							which performs both the casting and the instance-of check. 
							<a href="#polymorphicDispatch">Dispatch methods</a> are another alternative to casts that offers the potential
							to enhance the number of expected and handled types in subclasses.
						</p>
						</section>
						<!--  section -->
						<section id="operators" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Infix Operators and Operator Overloading</h2>
						<p>
							There are a couple of common predefined infix operators. These operators are not limited
							to operations on certain types. Instead an operator-to-method mapping allows to redefine the 
							operators for any type just by implementing the corresponding method signature. As an example, the 
							runtime library contains a class <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/BigDecimalExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.BigDecimalExtensions">BigDecimalExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/BigDecimalExtensions.java">(src)</a> that defines operators for 
							<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/math/BigDecimal.html">BigDecimals</a>. The following code is therefore perfectly valid:
							</p>
							<pre class="prettyprint lang-xtend linenums">
val x = 2.71BD
val y = 3.14BD
val sum = x + y    // calls BigDecimalExtension.operator_plus(x,y)</pre>
							<p>
						</p>
						<p>
							This is the complete list of all available operators and their corresponding method signatures:
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td><code class="prettyprint lang-xtend">e1 += e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_add(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 -= e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_remove(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 || e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_or(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &amp;&amp; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_and(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 == e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_equals(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 != e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_notEquals(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 === e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_tripleEquals(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 !== e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_tripleNotEquals(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &lt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_lessThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_greaterThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &lt;= e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_lessEqualsThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &gt;= e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_greaterEqualsThan(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 -&gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_mappedTo(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 .. e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_upTo(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &gt;.. e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_greaterThanDoubleDot(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 ..&lt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_doubleDotLessThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 =&gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_doubleArrow(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &lt;&lt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_doubleLessThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &gt;&gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_doubleGreaterThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &lt;&lt;&lt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_tripleLessThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &gt;&gt;&gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_tripleGreaterThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &lt;&gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_diamond(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 ?: e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_elvis(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &lt;=&gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_spaceship(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 + e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_plus(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 - e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_minus(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 * e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_multiply(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 / e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_divide(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 % e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_modulo(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 ** e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_power(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">! e1</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_not()</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">- e1</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_minus()</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">+ e1</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_plus()</code></td>
							</tr>
							</table>
							<p>
							
							    
							The table above also defines the operator precedence in ascending order. The blank lines separate 
							precedence levels. The assignment operators <code class="prettyprint lang-xtend">+=</code> and <code class="prettyprint lang-xtend">-=</code> are right-to-left associative in the same way 
							as the plain assignment operator <code class="prettyprint lang-xtend">=</code> is. That is a = b = c is executed as a = (b = c), all
							other operators are left-to-right associative. Parentheses can be used to adjust the default 
							precedence and associativity.
						</p>
						<!-- subsection -->
						<section id="_11" style="padding-top: 68px; margin-top: -68px;">
						<h3>Short-Circuit Boolean Operators</h3>
						<p>
							If the operators <code class="prettyprint lang-xtend">||</code>, <code class="prettyprint lang-xtend">&amp;&amp;</code>, and <code class="prettyprint lang-xtend">?:</code> are bound to the library methods 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/BooleanExtensions.html"><code class="prettyprint lang-xtend">BooleanExtensions.operator_and(boolean l, boolean r)</code></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/BooleanExtensions.java">(src)</a>, 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/BooleanExtensions.html"><code class="prettyprint lang-xtend">BooleanExtensions.operator_or(boolean l, boolean r)</code></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/BooleanExtensions.java">(src)</a>  resp.
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/ObjectExtensions.html"><code class="prettyprint lang-xtend">&lt;T&gt; T operator_elvis(T first, T second)</code></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/ObjectExtensions.java">(src)</a> the operation is inlined and evaluated in short circuit mode.
							That means that the right hand operand might not be evaluated at all in the following cases: 
							</p>
							<ol>
								<li>in the case of <code class="prettyprint lang-xtend">||</code> the operand on the right hand side is not evaluated if the left 
								    operand evaluates to <code class="prettyprint lang-xtend">true</code>.</li>
								<li>in the case of <code class="prettyprint lang-xtend">&amp;&amp;</code> the operand on the right hand side is not evaluated if the left 
								    operand evaluates to <code class="prettyprint lang-xtend">false</code>.</li>
								<li>in the case of <code class="prettyprint lang-xtend">?:</code> the operand on the right hand side is not evaluated if the left 
								    operand evaluates to <code class="prettyprint lang-xtend">null</code>.</li>
							</ol>
							<p>
						</p>
						<p>
							Still you can overload these operators for your types or even override it for booleans, in which case
							both operands are always evaluated and the defined method is invoked, i.e. no short-circuit execution is happening.
						</p>
						</section>
						<!-- subsection -->
						<section id="_12" style="padding-top: 68px; margin-top: -68px;">
						<h3>Postfix Operators</h3>
						<p>
							The two postfix operators <code class="prettyprint lang-xtend">++</code> and <code class="prettyprint lang-xtend">--</code> use the following method mapping:
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td><code class="prettyprint lang-xtend">e1++</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_plusPlus()</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1--</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_minusMinus()</code></td>
							</tr>
							</table>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="_13" style="padding-top: 68px; margin-top: -68px;">
						<h3>Defined Operators in The Library</h3>
						<p>
							Xtend offers operators for common types from the JDK.
						</p>
						<!-- subsection -->
						<section id="_14" style="padding-top: 68px; margin-top: -68px;">
						<h4>Equality Operators</h4>
						<p>
							In Xtend the equals operators (<code class="prettyprint lang-xtend">==</code>,<code class="prettyprint lang-xtend">!=</code>) are bound to <code class="prettyprint lang-xtend">Object.equals</code>. So you can write:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
if (name == 'Homer')
	println('Hi Homer')</pre>
							<p>
						</p>
						<p>
							Java's identity equals semantic is mapped to the tripple-equals operators <code class="prettyprint lang-xtend">===</code> and <code class="prettyprint lang-xtend">!==</code> in Xtend.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
if (someObject === anotherObject)
	println('same objects')</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="_15" style="padding-top: 68px; margin-top: -68px;">
						<h4>Comparison Operators</h4>
						<p>
							In Xtend the usual comparison operators (<code class="prettyprint lang-xtend">&gt;</code>,<code class="prettyprint lang-xtend">&lt;</code>,<code class="prettyprint lang-xtend">&gt;=</code>, and <code class="prettyprint lang-xtend">&lt;=</code>) work as expected on the primitive numbers:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
if (42 &gt; myNumber) {
	...
}</pre>
							<p>
						</p>
						<p>
							In addition these operators are overloaded for all instances of <code class="prettyprint lang-xtend">java.lang.Comparable</code>. So you can
							also write
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
if (startTime &lt; arrivalTime)
	println("You are too late!")</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="_16" style="padding-top: 68px; margin-top: -68px;">
						<h4>Arithmetic Operators</h4>
						<p>
							The arithmetic operators (<code class="prettyprint lang-xtend">+</code>,<code class="prettyprint lang-xtend">-</code>,<code class="prettyprint lang-xtend">*</code>,<code class="prettyprint lang-xtend">/</code>,<code class="prettyprint lang-xtend">%</code>, and <code class="prettyprint lang-xtend">**</code>) are not only available for
							the primitive types, but also for other reasonable types such as <code class="prettyprint lang-xtend">BigDecimal</code> and <code class="prettyprint lang-xtend">BigInteger</code>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val x = 2.71BD
val y = 3.14BD
val sum = x + y    // calls BigDecimalExtension.operator_plus(x,y)</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="_17" style="padding-top: 68px; margin-top: -68px;">
						<h4>Elvis Operator</h4>
						<p>
							In addition to <a href="#nullSafeFeatureCalls">null-safe feature calls</a> Xtend supports the elvis operator known
							from Groovy.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val salutation = person.firstName ?: 'Sir/Madam'</pre>
							<p>
						</p>
						<p>
							The right hand side of the expression is only evaluated if the left side was <code class="prettyprint lang-xtend">null</code>.
						</p>
						</section>
						<!-- subsection -->
						<section id="_18" style="padding-top: 68px; margin-top: -68px;">
						<h4>With Operator</h4>
						<p>
							The with operator is very handy when you want to initialize objects or when you want to use a particular
							instance a couple of time in subsequent lines of code. It simply passes the left hand side
							argument to the lambda on the right hand and returns the left hand after that.
						</p>
						<p>
							Here's an example:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val person = new Person =&gt; [
	firstName = 'Homer'
	lastName = 'Simpson'
	address = new Address =&gt; [
		street = '742 Evergreen Terrace'
		city = 'SpringField'
	]
]</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="_19" style="padding-top: 68px; margin-top: -68px;">
						<h4>Range Operators</h4>
						<p>
							There are three different range operators. The most useful ones are <code class="prettyprint lang-xtend">..&lt;</code> and <code class="prettyprint lang-xtend">&gt;..</code> which create exclusive ranges.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
// iterate the list forwards
for (i : 0 ..&lt; list.size) {
	val element = list.get(i)
	...
}</pre>
							<p>
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
// or backwards
for (i : list.size &gt;.. 0) {
	val element = list.get(i)
	...
}</pre>
							<p>
						</p>
						<p>
							In addition there is the inclusive range, which is nice if you know both ends well. In the movies example
							the range is used to check whether a movie was made in a certain decade:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
movies.filter[1980..1989.contains(year)]</pre>
							<p>
						</p>
						<p>
							Please keep in mind that there are other means to iterator lists, too. For example, you may want to use the <code class="prettyprint lang-xtend">forEach</code> extension
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
list.forEach[ element, index |
	.. // if you need access to the current index
]
list.reverseView.forEach[
  .. // if you just need the element it in reverse order
]</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="_20" style="padding-top: 68px; margin-top: -68px;">
						<h4>Pair Operator</h4>
						<p>
							Sometimes you want to use a pair of two elements locally without introducing a new structure. In Xtend you can
							use the <code class="prettyprint lang-xtend">-&gt;</code>-operator which returns an instance of <code class="prettyprint lang-xtend">Pair&lt;A,B&gt;</code>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val nameAndAge = 'Homer' -&gt; 42</pre>
							<p>
						</p>
						<p>
							If you want to surface a such a pair of values on the interface of a method or field, it's generally a better
							idea to use a data class with a well defined name, instead:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Data class NameAndAge {
	String name
	int age
}</pre>
							<p>
						</p>
						</section>
						</section>
						<!-- subsection -->
						<section id="assignments" style="padding-top: 68px; margin-top: -68px;">
						<h3>Assignments</h3>
						<p>
							<a href="#variableDeclaration">Local variables</a> can be assigned using the <code class="prettyprint lang-xtend">=</code> operator.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
var greeting = 'Hello'
if (isInformal)
  greeting = 'Hi'</pre>
							<p>
						</p>
						<p>
							Of course, also non-final fields can be set using an assignment: 
							</p>
							<pre class="prettyprint lang-xtend linenums">
myObj.myField = 'foo'</pre>
							<p>
						</p>
						<!-- subsection -->
						<section id="propertyAssignments" style="padding-top: 68px; margin-top: -68px;">
						<h4>Setting Properties</h4>
						<p>
							The lack of properties in Java leads to a lot of syntactic noise when working with data objects.
							As Xtend is designed to integrate with existing Java APIs it respects the Java Beans convention,
							hence you can call a setter using an assignment:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
myObj.myProperty = 'foo' // calls myObj.setMyProperty("foo")</pre>
							<p>
						</p>
						<p>
							The setter is only used if the field is not accessible from the given context. That is why the 
							<a href="#propertyAnnotation">@Property annotation</a> would rename the local field to <code class="prettyprint lang-xtend">_myProperty</code>.
						</p>
						<p>
							The return type of an assignment is the type of the right hand side, in case it is a simple assignment.
							If it is translated to a setter method it yields whatever the setter method returns.
						</p>
						</section>
						<!-- subsection -->
						<section id="assignmentOperators" style="padding-top: 68px; margin-top: -68px;">
						<h4>Assignment Operators</h4>
						<p>
							Compound assignment operators can be used as a shorthand for the assignment of a binary expression.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
var BigDecimal bd = 45bd
bd += 12bd // equivalent to bd = bd + 12bd
bd -= 12bd // equivalent to bd = bd - 12bd
bd /= 12bd // equivalent to bd = bd / 12bd
bd *= 12bd // equivalent to bd = bd * 12bd</pre>
							<p>
						</p>
						<p>
							Compound assignments work automatcially when the infix operator is declared. The following compound assignment operators 
							are supported:
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td><code class="prettyprint lang-xtend">e1 += e2</code></td>
							<td><code class="prettyprint lang-xtend">+</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 -= e2</code></td>
							<td><code class="prettyprint lang-xtend">-</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 *= e2</code></td>
							<td><code class="prettyprint lang-xtend">*</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 /= e2</code></td>
							<td><code class="prettyprint lang-xtend">/</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 %= e2</code></td>
							<td><code class="prettyprint lang-xtend">%</code></td>
							</tr>
							</table>
							<p>
						</p>
						</section>
						</section>
						</section>
						<!--  section -->
						<section id="blocks" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Blocks</h2>
						<p>
							The block expression allows to have imperative code sequences. It consists of a sequence of 
							expressions. The value of the last expression in the block is the value of the complete block. 
							The type of a block is also the type of the last expression. Empty blocks return <code class="prettyprint lang-xtend">null</code> and
							have the type <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html"><abbr title="java.lang.Object">Object</abbr></a>. 
							<a href="#variableDeclaration">Variable declarations</a> are only allowed within blocks and cannot be used as 
							a block's last expression.
						</p>
						<p>
							A block expression is surrounded by curly braces. The expressions in a block can be terminated by an optional semicolon.
						</p>
						<p>
							Here are two examples:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
{
  doSideEffect("foo")
  result
}</pre>
							<p>
							
							</p>
							<pre class="prettyprint lang-xtend linenums">
{
  var x = greeting;
  if (x.equals("Hello ")) {
    x + "World!" 
  } else {
    x
  }
}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="variableDeclaration" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Variable Declarations</h2>
						<p>
							Variable declarations are only allowed within <a href="#blocks">blocks</a>. They are visible from any 
							subsequent expressions in the block.
						</p>
						<p>
							A variable declaration starting with the keyword <code class="prettyprint lang-xtend">val</code> denotes a value, which
							is essentially a final, unsettable variable. The variable needs to be declared with the 
							keyword <code class="prettyprint lang-xtend">var</code>, which stands for 'variable' if it should be allowed to reassign its value.
						</p>
						<p>
							A typical example for using <code class="prettyprint lang-xtend">var</code> is a counter in a loop:
							</p>
							<pre class="prettyprint lang-xtend linenums">
{
  val max = 100
  var i = 0
  while (i &lt; max) {
    println("Hi there!")
    i = i + 1
  }
}</pre>
							<p>
						</p>
						<p>
							Shadowing variables from outer scopes is not allowed, the only exception is the 
							<a href="#implicitVariables">implicit variable</a> <code class="prettyprint lang-xtend">it</code>.
						</p>
						<p>
							Variables declared outside of a lambda expression using the <code class="prettyprint lang-xtend">var</code> keyword are not accessible from within the
							lambda expressions.
						</p>
						<p>
							A local variable can be marked with the <code class="prettyprint lang-xtend">extension</code> keyword to make its methods available as extensions (<a href="#Extension_Provider">see
							extension provider</a>).
						</p>
						<!-- subsection -->
						<section id="_21" style="padding-top: 68px; margin-top: -68px;">
						<h3>Typing</h3>
						<p>
							The type of the variable itself can either be explicitly declared or it can be inferred from the initializer
							expression. Here is an example for an explicitly declared type:
							</p>
							<pre class="prettyprint lang-xtend linenums">
var List&lt;String&gt; strings = new ArrayList</pre>
							<p>
						</p>
						<p>
							In such cases, the type of the right hand expression must conform to the type 
							of the expression on the left side.
						</p>
						<p>
							Alternatively the type can be inferred from the initializater: 
							</p>
							<pre class="prettyprint lang-xtend linenums">
var strings = new ArrayList&lt;String&gt; // -&gt; msg is of type ArrayList&lt;String&gt;</pre>
							<p>
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="featureCalls" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Field Access and Method Invocation</h2>
						<p>
							A simple name can refer to a local field, variable or parameter. In addition
							it can point to a method with zero arguments, since empty parentheses are optional.
						</p>
						<!-- subsection -->
						<section id="propertyAccess" style="padding-top: 68px; margin-top: -68px;">
						<h3>Property Access</h3>
						<p>
							If there is no field with the given name and also no method with the name and zero parameters
							accessible, a simple name binds to a corresponding Java-Bean getter method if available:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
myObj.myProperty // myObj.getMyProperty()  (.. in case myObj.myProperty is not visible.)</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="implicitVariables" style="padding-top: 68px; margin-top: -68px;">
						<h3>Implicit Variables <strong>this</strong> and <strong>it</strong></h3>
						<p>
							Like in Java the current instance of the class is bound to <code class="prettyprint lang-xtend">this</code>. This allows for either qualified
							field access or method invocations like in:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
this.myField</pre>
							<p>
						</p>
						<p>
							or it is possible to omit the receiver:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
myField</pre>
							<p>
						</p>
						<p>
							You can use the variable name <code class="prettyprint lang-xtend">it</code> to get the same behavior for any variable or parameter:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val it = new Person
name = 'Horst' // translates to 'it.setName("Horst");'</pre>
							<p>
						</p>
						<p>
							Another speciality of the variable <code class="prettyprint lang-xtend">it</code> is that it is allowed to be shadowed. This is especially useful
							when used together with <a href="#lambdas">lambda expressions</a>.
						</p>
						<p>
							As <code class="prettyprint lang-xtend">this</code> is bound to the surrounding object in Java, <code class="prettyprint lang-xtend">it</code> can be used
							in finer-grained constructs such as <a href="#lambdas">lambda expressions</a>. That is why <code class="prettyprint lang-xtend">it.myProperty</code> has 
							higher precedence than <code class="prettyprint lang-xtend">this.myProperty</code>.
						</p>
						</section>
						<!-- subsection -->
						<section id="staticAccess" style="padding-top: 68px; margin-top: -68px;">
						<h3>Static Access</h3>
						<p>
							For accessing a static field or method you can use the recommended Java syntax or the more explicit double colon <code class="prettyprint lang-xtend">::</code>. 
							That means, the following epxressions are pairwise equivalent:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
MyClass.myField
MyClass::myField</pre>
							<p>
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
com.acme.MyClass.myMethod('foo')
com.acme.MyClass::myMethod('foo')
com::acme::MyClass::myMethod('foo')</pre>
							<p>
						</p>
						<p>
							Alternatively you could import the method or field using a <a href="#imports">static import</a>.
						</p>
						</section>
						<!-- subsection -->
						<section id="nullSafeFeatureCalls" style="padding-top: 68px; margin-top: -68px;">
						<h3>Null-Safe Feature Call</h3>
						<p>
							Checking for <code class="prettyprint lang-xtend">null</code> references can make code very unreadable. In many situations it is ok for an 
							expression to return <code class="prettyprint lang-xtend">null</code> if a receiver was <code class="prettyprint lang-xtend">null</code>. Xtend supports the safe navigation 
							operator <code class="prettyprint lang-xtend">?.</code> to make such code better readable.
						</p>
						<p>
							Instead of writing 
							</p>
							<pre class="prettyprint lang-java linenums">
if (myRef != null) myRef.doStuff()</pre>
							<p>
						</p>
						<p>
							one can write
							</p>
							<pre class="prettyprint lang-xtend linenums">
myRef?.doStuff</pre>
							<p>
						</p>
						<p>
							Arguments that would be passed to the method are only evaluated if the method will be invoked at all.
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="constructorCall" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Constructor Call</h2>
						<p>
							Constructor calls have the same syntax as in Java. The only difference is that empty parentheses
							are optional:
							</p>
							<pre class="prettyprint lang-xtend linenums">
new String() == new String
new ArrayList&lt;BigDecimal&gt;() == new ArrayList&lt;BigDecimal&gt;</pre>
							<p>
						</p>
						<p>
							If type arguments are omitted, they will be inferred from the current context similar to Java's
							diamond operator on generic method and constructor calls.
						</p>
						</section>
						<!--  section -->
						<section id="lambdas" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Lambda Expressions</h2>
						<p>
							A lambda expression is basically a piece of code, which is wrapped in an object to pass it around. As
							a Java developer it is best to think of a lambda expression as an anonymous class with a single method, i.e. 
							like in the following Java code :
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
// Java Code!
final JTextField textField = new JTextField();
textField.addActionListener(new ActionListener() {
  @Override
  public void actionPerformed(ActionEvent e) {
    textField.setText("Something happened!");
  }
});</pre>
							<p>
						</p>
						<p>
							This kind of anonymous classes can be found everywhere in Java code and have always been the poor-man's replacement
							for lambda expressions in Java.
						</p>
						<p>
							Xtend not only supports lambda expressions, but offers an extremely dense syntax for it. That is the
							code above can be written in Xtend like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val textField = new JTextField
textField.addActionListener([ ActionEvent e |
  textField.text = "Something happened!"
])</pre>
							<p>
						</p>
						<p>
							As you might have guessed, a lambda expression is surrounded by square brackets (inspired from Smalltalk).
							Also a lambda expression like a method declares parameters. The lambda above has one parameter called <code class="prettyprint lang-xtend">e</code> which is of
							type <code class="prettyprint lang-xtend">ActionEvent</code>. You do not have to specify the type explicitly because it can be inferred from
							the context:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
textField.addActionListener([ e |
  textField.text = "Something happened!"
])</pre>
							<p>
						</p>
						<p>
							Also as lambdas with one parameter are a common case, there is a special short hand notation for them,
							which is to leave the declaration including the vertical bar out. The name of the <a href="#implicitVariables">single variable</a>
							will be <code class="prettyprint lang-xtend">it</code> in that case:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
textField.addActionListener([
  textField.text = "Something happened!"
])</pre>
							<p>
						</p>
						<p>
							A lambda expression with zero arguments is written like this (note the bar after the opening bracket):
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val Runnable runnable = [ |
  println("Hello I'm executed!")
]</pre>
							<p>
						</p>
						<p>
							When a method call's last parameter is a lambda it can be passed right after the parameter list.
							For instance if you want to sort some strings by their length, you could write :
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
Collections.sort(someStrings) [ a, b |
  a.length - b.length
]</pre>
							<p>
						</p>
						<p>
							which is just the same as writing
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
Collections.sort(someStrings, [ a, b |
  a.length - b.length
])</pre>
							<p>
						</p>
						<p>
							Since you can leave out empty parentheses for methods which get a lambda as their only argument, you can reduce
							the code above further down to:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
textField.addActionListener [
  textField.text = "Something happened!"
]</pre>
							<p>
						</p>
						<p>
							A lambda expression also captures the current scope. Any final local variables and all parameters that are visible at construction time can be referred to
							from within the lambda body. 
							That is exactly what we did with the variable <code class="prettyprint lang-xtend">textField</code> above.
						</p>
						<p>
							The variable <code class="prettyprint lang-xtend">this</code> refers to the outer class. The lambda instance itself is available with the identifier
							<code class="prettyprint lang-xtend">self</code>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val lineReader = new LineReader(r);
val AbstractIterator&lt;String&gt; lineIterator = [|
	val result = lineReader.readLine 
	if (result==null)
		self.endOfData
	return result
]</pre>
							<p>
						</p>
						<!-- subsection -->
						<section id="closureTypes" style="padding-top: 68px; margin-top: -68px;">
						<h3>Typing</h3>
						<p>
							Lambdas are expressions which produce <strong>Function</strong> objects. The type of a lambda expression generally depends on the target
							type, as seen in the previous examples. That is, the lambda expression can coerce to any interface or abstract class which has declared only 
							one abstract method. This allows for using lambda expressions in many existing Java
							APIs directly.
						</p>
						<p>
							However, if you write a lambda expression without having any target type expectation, like in the following
							assignment:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val toUpperCaseFunction = [ String s | s.toUpperCase ] // inferred type is (String)=&gt;String</pre>
							<p>
						</p>
						<p>
							The type will be one of the inner types found in <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/Functions.html"><abbr title="org.eclipse.xtext.xbase.lib.Functions">Functions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Functions.java">(src)</a> or <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.5/org/eclipse/xtext/xbase/lib/Procedures.html"><abbr title="org.eclipse.xtext.xbase.lib.Procedures">Procedures</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Procedures.java">(src)</a>.
							It is a procedure if the return type is <code class="prettyprint lang-xtend">void</code>, otherwise it is a function.
						</p>
						<p>
							Xtend supports a shorthand syntax for function types. Instead of writing <code class="prettyprint lang-xtend">Function1&lt;? super String,? extends String&gt;</code>
							which is what you will find in the generated Java code, you can simply write <code class="prettyprint lang-xtend">(String)=&gt;String</code>.
						</p>
						<p>
							Example:
							</p>
							<pre class="prettyprint lang-xtend linenums">
val (String)=&gt;String stringToStringFunction = [ toUpperCase ]
// or
val Function1&lt;? super String,? extends String&gt; same = [ toUpperCase ]
// or
val stringToStringFunction2 = [ String s | s.toUpperCase ] // inferred type is (String)=&gt;String</pre>
							<p>
						</p>
						<p>
							Checked exceptions that are thrown in the body of a lambda expression but not declared in the implemented method of the target type are thrown using the 
							<a href="#declaredExceptions">sneaky-throw technique</a>.
							Of course you can always <a href="#Xtend_Expressions_TryCatch">catch and handle</a> them.
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="anonymousClasses" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Anonymous Classes</h2>
						<p>
							An anonymous class in Xtend has the very same semantics as in Java (see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9.5">Java Language Sepcification</a>).
							Here's an example:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val tabListener = new ActionBar.TabListener() {
  override onTabSelected(ActionBar.Tab tab, FragmentTransaction ft) {
    // show the given tab
  }

  override onTabUnselected(ActionBar.Tab tab, FragmentTransaction ft) {
    // hide the given tab
  }

  override onTabReselected(ActionBar.Tab tab, FragmentTransaction ft) {
    // probably ignore this event
  }
};</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="ifExpression" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">If Expression</h2>
						<p>
							An if-expression is used to choose between two different values based on a predicate.
						</p>
						<p>
							An expression 
							</p>
							<pre class="prettyprint lang-xtend linenums">
if (p) e1 else e2</pre>
							<p>
							 
							results in either the value <code class="prettyprint lang-xtend">e1</code> or <code class="prettyprint lang-xtend">e2</code> depending on whether the predicate <code class="prettyprint lang-xtend">p</code> evaluates 
							to <code class="prettyprint lang-xtend">true</code> or <code class="prettyprint lang-xtend">false</code>. The else part is optional which is a shorthand for an else branch
							that returns the default value of the current type, e.g. for reference type this is equivalent to <code class="prettyprint lang-xtend">else null</code>.
							That means
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
if (foo) x</pre>
							<p>
						</p>
						<p>
							is a short hand for
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
if (foo) x else null</pre>
							<p>
						</p>
						<p>
							The type of an if expression is the common super type of the return types <code class="prettyprint lang-xtend">T1</code> and <code class="prettyprint lang-xtend">T2</code> 
							of the two expression <code class="prettyprint lang-xtend">e1</code> and <code class="prettyprint lang-xtend">e2</code>.
						</p>
						<p>
							While the if expression has the syntax of Java's if statement it behaves more like Java's ternary operator 
							(<code class="prettyprint lang-java">predicate ? thenPart : elsePart</code>), because it is an expression and returns a value.
							Consequently, you can use if expressions deeply nested within expressions:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val name = if (firstName != null) firstName + ' ' + lastName else lastName</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="switchExpression" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Switch Expression</h2>
						<p>
							The switch expression is very different from Java's switch statement. First, there is no fall through which means 
							only one <code class="prettyprint lang-xtend">case</code> is evaluated at most. Second, the use of <code class="prettyprint lang-xtend">switch</code> is not limited 
							to certain values but can be used for any object reference. <code class="prettyprint lang-xtend">Object.equals(Object)</code> is used to
							compare the value in the case with the one you are switching over.
							 
							Given the following example:
							 
							</p>
							<pre class="prettyprint lang-xtend linenums">
switch myString {
  case myString.length &gt; 5 : "a long string."
  case 'some' : "It's some string."
  default : "It's another short string."
}</pre>
							<p>
						</p>
						<p>
							the main expression <code class="prettyprint lang-xtend">myString</code> is evaluated first and then compared to each case sequentially.
							If the case expression is of type <code class="prettyprint lang-xtend">boolean</code>, the case matches if the expression evaluates
							to <code class="prettyprint lang-xtend">true</code>. If it is not of type <code class="prettyprint lang-xtend">boolean</code> it is compared to the value of the main
							expression using <code class="prettyprint lang-xtend">Object.equals(Object)</code>.
						</p>
						<p>
							If a case is a match, that is it evaluates to <code class="prettyprint lang-xtend">true</code> or the result equals the one we are switching
							over, the case expression after the colon is evaluated and is the result of the whole switch expression.
						</p>
						<p>
							The main expression can also be a computed value instead of a field or variable. If you want to reuse that value
							in the body of the switch expression, you can create a local value for that by using the following notation which
							is similar to the syntax in <a href="#forLoop"><code class="prettyprint lang-xtend">for</code> loops</a>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
switch myString : someComputation() {
  ..
}</pre>
							<p>
						</p>
						<!-- subsection -->
						<section id="_22" style="padding-top: 68px; margin-top: -68px;">
						<h3>Type guards</h3>
						<p>
							Instead of or in addition to the case guard you can specify a <strong>type guard</strong>. The case only matches if the 
							switch value conforms to this type. A case with both a type guard and a predicate only matches if both conditions match.
							If the switch value is a field, parameter or variable, it is automatically casted to the given type within the
							predicate and the case body.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def length(Object x) {
  switch x {
    String case x.length &gt; 0 : x.length // length is defined for String 
    List&lt;?&gt; : x.size    // size is defined for List
    default : -1
  }
}</pre>
							<p>
						</p>
						<p>
							Switches with type guards are a safe and much more readable alternative to instance of / casting cascades you 
							might know from Java.
						</p>
						</section>
						<!-- subsection -->
						<section id="_23" style="padding-top: 68px; margin-top: -68px;">
						<h3>Fall Through</h3>
						<p>
							You can have multiple type guards and case separate with a comma, to have all of them share the same then part.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def isMale(String salutation) {
  switch salutation {
    case "Mr.", 
    case "Sir" : true
    default : false
  }
}</pre>
							<p>
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="forLoop" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">For Loop</h2>
						<p>
							The for loop 
							</p>
							<pre class="prettyprint lang-xtend linenums">
for (T1 variable : arrayOrIterable) expression</pre>
							<p>
							 
							is used to execute a certain expression for each element of an array or an instance of 
							<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Iterable.html"><abbr title="java.lang.Iterable">Iterable</abbr></a>. The local <code class="prettyprint lang-xtend">variable</code> is final, hence cannot be updated.
						</p>
						<p>
							The type of a for loop is <code class="prettyprint lang-xtend">void</code>. The type of the local variable can be inferred from the 
							iterable or array that is processed.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
for (String s : myStrings) {
  doSideEffect(s)
}

for (s : myStrings)
  doSideEffect(s)</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="traditionalForLoop" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Basic For Loop</h2>
						<p>
							The traditional for loop 
							</p>
							<pre class="prettyprint lang-xtend linenums">
for (&lt;init-expression&gt; ;  &lt;predicate&gt; ; &lt;update-expression&gt;) body-expression</pre>
							<p>
							 
							is very similar to the one known from Java, or even C. When executed, it first executes the <code class="prettyprint lang-xtend">init-expression</code>, 
							where local variables can be declared. Next the <code class="prettyprint lang-xtend">predicate</code> is executed and if it evaluates to <code class="prettyprint lang-xtend">true</code>, the <code class="prettyprint lang-xtend">body-expression</code> is executed.
							On any subsequent iterations the <code class="prettyprint lang-xtend">update-expressio</code> is executed instead of the init-expression. This happens until the <code class="prettyprint lang-xtend">predicate</code> returns <code class="prettyprint lang-xtend">false</code>.
						</p>
						<p>
							The type of a for loop is <code class="prettyprint lang-xtend">void</code>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
for (val i = 0 ; i &lt; s.length ; i++) {
  println(s.subString(0,i)
}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="whileExpression" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">While Loop</h2>
						<p>
							A while loop 
							</p>
							<pre class="prettyprint lang-xtend linenums">
while (predicate) expression</pre>
							<p>
							 
							is used to execute a certain expression unless the predicate is evaluated to <code class="prettyprint lang-xtend">false</code>. 
							The type of a while loop is <code class="prettyprint lang-xtend">void</code>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
while (true) {
  doSideEffect("foo")
}

while ((i=i+1) &lt; max) 
  doSideEffect("foo")</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="doWhileExpression" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Do-While Loop</h2>
						<p>
							A do-while loop 
							</p>
							<pre class="prettyprint lang-xtend linenums">
do expression while (predicate)</pre>
							<p>
							 
							is used to execute a certain expression until the predicate is evaluated to <code class="prettyprint lang-xtend">false</code>. 
							The difference to the <a href="#whileExpression">while loop</a> is that the execution starts by executing 
							the block once before evaluating the predicate for the first time. The type of a do-while 
							loop is <code class="prettyprint lang-xtend">void</code>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
do {
  doSideEffect("foo");
} while (true)


do doSideEffect("foo") while ((i=i+1)&lt;max)</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="Xtend_Expressions_Return" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Return Expression</h2>
						<p>
							A method or lambda expression automatically returns the value of its body expression.
							If it is a <a href="#blocks">block expression</a> this is the value of the last expression in it.
							However, sometimes you want to return early or make it explicit.
						</p>
						<p>
							The syntax is just like in Java:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
listOfStrings.map [ e | 
  if (e==null) 
    return "NULL"
  e.toUpperCase
]</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="Xtend_Expressions_Throw" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Throwing Exceptions</h2>
						<p>
							Throwing <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Throwable.html"><abbr title="java.lang.Throwable">Throwable</abbr></a>s up the call stack has the same semantics and syntax 
							as in Java.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
{
  ...
  if (myList.isEmpty)
    throw new IllegalArgumentException("the list must not be empty")
  ...
}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="Xtend_Expressions_TryCatch" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Try, Catch, Finally</h2>
						<p>
							The try-catch-finally expression is used to handle exceptional situations.
							Checked exceptions are treated like runtime exceptions and only optionally validated. 
							You can but do not have to catch them as they
							will be silently thrown (see the <a href="#declaredExceptions">section on declared exceptions</a>).
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
try {
  throw new RuntimeException()
} catch (NullPointerException e) {
  // handle e
} finally {
  // do stuff
}</pre>
							<p>
						</p>
						<p>
							For try-catch it is again beneficial that it is an expression, because you can write code like the following
							and do not have to rely on non-final variables:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val name = try {
    readFromFile
  } catch (IOException e) {
    "unknown"
  }</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="Xtend_Expressions_Synchronized" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Synchronized</h2>
						<p>
							The synchonized expression does the same as it does in Java (see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.19">Java Language Specification</a>).
							The only difference is that in Xtend it is an expression and can therefore be used at more places.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
synchronized(lock) {
  println("Hello")
}</pre>
							<p>
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val name = synchronized(lock) { 
  doStuff() 
}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="templates" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Template Expressions</h2>
						<p>
							Templates allow for readable string concatenation. Templates are surrounded by triple single quotes (<code class="prettyprint lang-xtend">'''</code>). 
							A template expression can span multiple lines and expressions can be nested which are evaluated and their <code class="prettyprint lang-xtend">toString()</code> 
							representation is automatically inserted at that position.
						</p>
						<p>
							The terminals for interpolated expression are so called guillemets <code class="prettyprint lang-xtend">&laquo;expression&raquo;</code>. They read nicely and are not often used
							in text so you seldom need to escape them. These escaping conflicts are the reason why
							template languages often use longer character sequences like e.g. <code class="prettyprint lang-xtend">&lt;%= expression %&gt;</code> in JSP, for the price of worse readability. 
							The downside with the guillemets in Xtend is that you will have to have a consistent encoding. Always use UTF-8 and you are good.
						</p>
						<p>
							If you use the Eclipse plug-in the guillemets will be inserted on content assist
							within a template. They are additionally bound to <strong>CTRL+SHIFT+&lt;</strong> and <strong>CTRL+SHIFT+</strong> for <code class="prettyprint lang-xtend">&laquo;</code> and <code class="prettyprint lang-xtend">&raquo;</code> respectively.
							On a Mac they are also available with <strong>alt+q</strong> (<code class="prettyprint lang-xtend">&laquo;</code>) and <strong>alt+Q</strong> (<code class="prettyprint lang-xtend">&raquo;</code>).
						</p>
						<p>
							Let us have a look at an example of how a typical method with a template expressions looks like:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def someHTML(String content) '''
  &lt;html&gt;
    &lt;body&gt;
      &laquo;content&raquo;
    &lt;/body&gt;
  &lt;/html&gt;
'''</pre>
							<p>
						</p>
						<p>
							As you can see, template expressions can be used as the body of a method.
							If an interpolation expression evaluates to <code class="prettyprint lang-xtend">null</code> an empty string is added.
						</p>
						<p>
							Template expressions can occur everywhere. 
							Here is an example showing it in conjunction with the powerful <a href="#switchExpression">switch expression</a>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def toText(Node n) {
  switch n {
    Contents : n.text

    A : '''&lt;a href="&laquo;n.href&raquo;"&gt;&laquo;n.applyContents&raquo;&lt;/a&gt;'''

    default : '''
        &lt;&laquo;n.tagName&raquo;&gt;
          &laquo;n.applyContents&raquo;
        &lt;/&laquo;n.tagName&raquo;&gt;
    '''
  }
}</pre>
							<p>
						</p>
						<!-- subsection -->
						<section id="templateIF" style="padding-top: 68px; margin-top: -68px;">
						<h3>Conditions in Templates</h3>
						<p>
							There is a special <code class="prettyprint lang-xtend">IF</code> to be used within templates:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def someHTML(Paragraph p) '''
  &lt;html&gt;
    &lt;body&gt;
      &laquo;IF p.headLine != null&raquo;
        &lt;h1&gt;&laquo;p.headline&raquo;&lt;/h1&gt;
      &laquo;ENDIF&raquo;
      &lt;p&gt;
        &laquo;p.text&raquo;
      &lt;/p&gt;
    &lt;/body&gt;
  &lt;/html&gt;
'''</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="templateFOREACH" style="padding-top: 68px; margin-top: -68px;">
						<h3>Loops in Templates</h3>
						<p>
							Also a <code class="prettyprint lang-xtend">FOR</code> expression is available:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def someHTML(List&lt;Paragraph&gt; paragraphs) '''
  &lt;html&gt;
    &lt;body&gt;
      &laquo;FOR p : paragraphs&raquo;
        &laquo;IF p.headLine != null&raquo;
          &lt;h1&gt;&laquo;p.headline&raquo;&lt;/h1&gt;
        &laquo;ENDIF&raquo;
        &lt;p&gt;
          &laquo;p.text&raquo;
        &lt;/p&gt;
      &laquo;ENDFOR&raquo;
    &lt;/body&gt;
  &lt;/html&gt;
'''</pre>
							<p>
						</p>
						<p>
							The for expression optionally allows to specify what to prepend (<code class="prettyprint lang-xtend">BEFORE</code>), put in-between (<code class="prettyprint lang-xtend">SEPARATOR</code>), and what to
							put at the end (<code class="prettyprint lang-xtend">AFTER</code>) of all iterations. <code class="prettyprint lang-xtend">BEFORE</code> and <code class="prettyprint lang-xtend">AFTER</code>
							are only executed if there is at least one iteration. (<code class="prettyprint lang-xtend">SEPARATOR</code>) is only added between
							iterations. It is executed if there are at least two iterations.
						</p>
						<p>
							Here is an example:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def someHTML(List&lt;Paragraph&gt; paragraphs) '''
  &lt;html&gt;
    &lt;body&gt;
      &laquo;FOR p : paragraphs BEFORE '&lt;div&gt;' SEPARATOR '&lt;/div&gt;&lt;div&gt;' AFTER '&lt;/div&gt;'&raquo;
        &laquo;IF p.headLine != null&raquo;
          &lt;h1&gt;&laquo;p.headline&raquo;&lt;/h1&gt;
        &laquo;ENDIF&raquo;
        &lt;p&gt;
          &laquo;p.text&raquo;
        &lt;/p&gt;
      &laquo;ENDFOR&raquo;
    &lt;/body&gt;
  &lt;/html&gt;
'''</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="templateType" style="padding-top: 68px; margin-top: -68px;">
						<h3>Typing</h3>
						<p>
							The template expression is of type <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/CharSequence.html"><abbr title="java.lang.CharSequence">CharSequence</abbr></a>. It is automatically converted
							to <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html"><abbr title="java.lang.String">String</abbr></a> if that is the expected target type.
						</p>
						</section>
						<!-- subsection -->
						<section id="WhitespaceHandling" style="padding-top: 68px; margin-top: -68px;">
						<h3>White Space Handling</h3>
						<p>
							One of the key features of templates is the smart handling of white space in the template output. 
							The white space is not written into the output data structure as is but preprocessed. This allows 
							for readable templates as well as nicely formatted output. The following three rules are applied 
							when the template is evaluated:
						</p>
						<p>
							</p>
							<ol>
								<li>Indentation in the template that is relative to a control structure will not be propagated 
								    to the output string. A control structure is a <code class="prettyprint lang-xtend">FOR</code>-loop or a condition 
								    (<code class="prettyprint lang-xtend">IF</code>) as well as the opening and closing marks of the template string itself.
								    
								    The indentation is considered to be relative to such a control structure if the previous 
								    line ends with a control structure followed by optional white space. The amount of indentation white 
								    space is not taken into account but the delta to the other lines.</li>
								<li>Lines that do not contain any static text which is not white space but do contain control 
								    structures or invocations of other templates which evaluate to an empty string, will not 
								    appear in the output.</li>
								<li>Any newlines in appended strings (no matter they are created with template expressions or not) will
								    be prepended with the current indentation when inserted.</li>
							</ol>
							<p>
						</p>
						<p>
							Although this algorithm sounds a bit complicated at first it behaves very intuitively. In addition the
							syntax coloring in Eclipse communicates this behavior.
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/Xtend_template_coloring.png" alt="Syntax Coloring For Templates In Eclipse" width="566" height="213">
							</div>
							<p>
						</p>
						<p>
							The behavior is best described with a set of examples. The following table assumes a data structure 
							of nested nodes.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td></p>
							<pre class="prettyprint lang-xtend linenums">
class Template {
  def print(Node n) '''
    node &laquo;n.name&raquo; {}
  '''
}</pre>
							<p></td>
							<td></p>
							<pre class="prettyprint lang-xtend linenums">
node NodeName {}</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The indentation before <code class="prettyprint lang-xtend">node &laquo;n.name&raquo;</code> will be skipped as it is relative to the opening mark of
							the template string and thereby not considered to be relevant for the output but only for the readability 
							of the template itself.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td></p>
							<pre class="prettyprint lang-xtend linenums">
class Template {
  def print(Node n) '''
    node &laquo;n.name&raquo; {
      &laquo;IF hasChildren&raquo;
        &laquo;n.children.map[print]&raquo;
      &laquo;ENDIF&raquo;
    }
  '''
}</pre>
							<p></td>
							<td></p>
							<pre class="prettyprint lang-xtend linenums">
node Parent{
  node FirstChild {
  }
  node SecondChild {
    node Leaf {
    }
  }
}</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							As in the previous example, there is no indentation on the root level for the same reason.
							The first nesting level has only one indentation level in the output. This is derived from
							the indentation of the <code class="prettyprint lang-xtend">IF hasChildren</code> condition in the template which is nested in
							the node. The additional nesting of the recursive invocation <code class="prettyprint lang-xtend">children.map[print]</code> is not
							visible in the output as it is relative the the surrounding control structure. The line with
							<code class="prettyprint lang-xtend">IF</code> and <code class="prettyprint lang-xtend">ENDIF</code> contain only control structures thus they are skipped in 
							the output. Note the additional indentation of the node <strong>Leaf</strong> which happens due to the first rule:
							Indentation is propagated to called templates.
						</p>
						</section>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="activeAnnotations" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Active Annotations
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							<strong>Active Annotations</strong> allow developers to participate in the translation process of Xtend source code to Java code via library. That's useful in cases where Java requires to 
							write a lot of boilerplate manually. For instance, many of the good old design patterns fall into this category. With <strong>Active Annotations</strong> you no longer need to remember how the 
							<a href="http://en.wikipedia.org/wiki/Visitor_pattern">Visitor</a> or the <a href="http://en.wikipedia.org/wiki/Observer_pattern">Observer</a> pattern should be implemented. In Xtend you can implement the expansion 
							of such patterns in a library and let the compiler do the heavy lifting for you.
						</p>
						<p>
							An <strong>Active Annotation</strong> is just an annotation declared either in Java or Xtend, which is itself annotated with <a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/Active.html"><abbr title="org.eclipse.xtend.lib.macro.Active">@Active</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/Active.java">(src)</a>.
							<code class="prettyprint lang-xtend">@Active</code> takes a type literal as a parameter pointing to the processor.
						</p>
						<p>
							The IDE plugin comes with an example project, which you can easily materialize into your workspace. To
							do so use the new project wizard and in the category <strong>Xtend Examples</strong> choose the active annotation example.
							The examples contain three different annotations which we will use for further explanation.
						</p>
						<p>
							For instance, <code class="prettyprint lang-xtend">@Extract</code> is an annotation which extracts an interface for a class.
							The annotation declaration looks like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Active(ExtractProcessor)
annotation Extract {}</pre>
							<p>
						</p>
						<!--  section -->
						<section id="active_annotations_processor" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Annotation Processor</h2>
						<p>
							A processor class must implement one or both of the lifecycle call-back interfaces provided by the compiler.
							There are some base classes for the most common usecases. These implement both interfaces:
							</p>
							<ul>
								<li><a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/AbstractClassProcessor.html"><abbr title="org.eclipse.xtend.lib.macro.AbstractClassProcessor">AbstractClassProcessor</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/AbstractClassProcessor.java">(src)</a> is a base class for class annotations</li>
								<li><a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/AbstractMethodProcessor.html"><abbr title="org.eclipse.xtend.lib.macro.AbstractMethodProcessor">AbstractMethodProcessor</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/AbstractMethodProcessor.java">(src)</a> is a base class for method annotations</li>
								<li><a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/AbstractFieldProcessor.html"><abbr title="org.eclipse.xtend.lib.macro.AbstractFieldProcessor">AbstractFieldProcessor</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/AbstractFieldProcessor.java">(src)</a> is a base class for field annotations</li>
							</ul>
							<p>
						</p>
						<p>
							If you want to annotate other elements such as interfaces, parameters or constructors, you should have
							a look at the bases classes and adapt their implementation accordingly.
						</p>
						<!-- subsection -->
						<section id="active_annotations_register_globals" style="padding-top: 68px; margin-top: -68px;">
						<h3>Phase 1: Register Globals</h3>
						<p>
							The first phase in the lifecycle of the compiler is about indexing the types as globally available symbols. By implementing a <a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/RegisterGlobalsParticipant.html"><abbr title="org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant">RegisterGlobalsParticipant</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/RegisterGlobalsParticipant.java">(src)</a>
							you have the chance to create and register new Java types during this phase. It's important
							to do this in a first phase so later on the compiler can find and access these types.
						</p>
						<p>
							For example the ExtractProcessor adds one interface per annotated class:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class ExtractProcessor extends AbstractClassProcessor {
  
  override doRegisterGlobals(ClassDeclaration annotatedClass, RegisterGlobalsContext context) {
    context.registerInterface(annotatedClass.interfaceName)
  }

  def getInterfaceName(ClassDeclaration annotatedClass) {
    annotatedClass.qualifiedName+"Interface"
  }
  
  ...
}</pre>
							<p>
						</p>
						<p>
							The <a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/RegisterGlobalsContext.html"><abbr title="org.eclipse.xtend.lib.macro.RegisterGlobalsContext">RegisterGlobalsContext</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/RegisterGlobalsContext.java">(src)</a> provides all the services that are available during 
							this compilation step. It is passed into the method <code class="prettyprint lang-xtend">doRegisterGlobals()</code> along with a read-only representation of the annotated
							Xtend elements.
							The AbstractClassProcessor in this example is invoked for all classes that are annotated with <code class="prettyprint lang-xtend">@Extract</code>.
						</p>
						<p>
							The compiler calls <a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/RegisterGlobalsParticipant.html"><abbr title="org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant">RegisterGlobalsParticipant</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/RegisterGlobalsParticipant.java">(src)</a> once per compilation unit
							and provides access to all elements which are annotated with the <strong>active annotation</strong> this processor
							is registered for. Therefore the <code class="prettyprint lang-xtend">ExtractProcessor</code> is invoked with a list of all classes that are defined in the same Xtend file for
							all the files that are being compiled.
						</p>
						</section>
						<!-- subsection -->
						<section id="active_annotations_transformation_phase" style="padding-top: 68px; margin-top: -68px;">
						<h3>Phase 2: Transformation</h3>
						<p>
							In the second phase developers can modify the compiled Java classes and Java code. Annotation processors that implement
							<a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/TransformationParticipant.html"><abbr title="org.eclipse.xtend.lib.macro.TransformationParticipant">TransformationParticipant</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/TransformationParticipant.java">(src)</a> participate in this compile step. Similar to the 
							<a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/RegisterGlobalsParticipant.html"><abbr title="org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant">RegisterGlobalsParticipant</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/RegisterGlobalsParticipant.java">(src)</a> interface the compiler provides two
							arguments: The list of annotated elements and a <a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/TransformationContext.html"><abbr title="org.eclipse.xtend.lib.macro.TransformationContext">TransformationContext</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/TransformationContext.java">(src)</a>. The context provides services
							that are specific for this second step.
						</p>
						<p>
							A transformation participant can access and modify mutable Java elements. These are an in-memory representation of the generated Java code. They are usually
							very similar to the source elements, but can be modified and new methods, fields or constructors can be added. It is not possible to
							create new types during the transformation step.
						</p>
						<p>
							The <code class="prettyprint lang-xtend">ExtractProcessor</code> implements the method <code class="prettyprint lang-xtend">doTransform</code> like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class ExtractProcessor extends AbstractClassProcessor {
  
  override doRegisterGlobals(ClassDeclaration annotatedClass, RegisterGlobalsContext context) {
    context.registerInterface(annotatedClass.interfaceName)
  }

  def getInterfaceName(ClassDeclaration annotatedClass) {
    annotatedClass.qualifiedName+"Interface"
  }
  
  override doTransform(MutableClassDeclaration annotatedClass, extension TransformationContext context) {
    val interfaceType = findInterface(annotatedClass.interfaceName)
    
    // add the interface to the list of implemented interfaces
    annotatedClass.implementedInterfaces = annotatedClass.implementedInterfaces + #[interfaceType.newTypeReference]
    
    // add the public methods to the interface
    for (method : annotatedClass.declaredMethods) {
      if (method.visibility == Visibility.PUBLIC) {
        interfaceType.addMethod(method.simpleName) [
          docComment = method.docComment
          returnType = method.returnType
          for (p : method.parameters) {
            addParameter(p.simpleName, p.type)
          }
          exceptions = method.exceptions
        ]
      }
    }
  }
}</pre>
							<p>
						</p>
						<p>
							In the first line, <code class="prettyprint lang-xtend">findInterface</code> retrieves the interface which was registered during the registration of global symbols in the first phase:
							The method is defined in <a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/TransformationContext.html"><abbr title="org.eclipse.xtend.lib.macro.TransformationContext">TransformationContext</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/TransformationContext.java">(src)</a>
							which is used as an <a href="#Extension_Provider">extension provider</a>.
						</p>
						<p>
							Next up the newly created interface is added to the existing list of implemented interfaces.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
annotatedClass.implementedInterfaces = annotatedClass.implementedInterfaces + #[interfaceType.newTypeReference]</pre>
							<p>
						</p>
						<p>
							The code calls <code class="prettyprint lang-xtend">setImplementedInterfaces(Iterable&lt;TypeReference&gt;)</code> on the annotated class. The right
							hand side of the assignment is a concatenation of the existing implemented interfaces and a type reference
							pointing to the freshly created interface.
						</p>
						<p>
							A <a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/declaration/TypeReference.html"><abbr title="org.eclipse.xtend.lib.macro.declaration.TypeReference">TypeReference</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/declaration/TypeReference.java">(src)</a> can be created using one of the various
							methods from <a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/services/TypeReferenceProvider.html"><abbr title="org.eclipse.xtend.lib.macro.services.TypeReferenceProvider">TypeReferenceProvider</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/services/TypeReferenceProvider.java">(src)</a> which is a super type
							of <a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/TransformationContext.html"><abbr title="org.eclipse.xtend.lib.macro.TransformationContext">TransformationContext</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/TransformationContext.java">(src)</a>. These utilities are available as extensions, too.
						</p>
						</section>
						<!-- subsection -->
						<section id="active_annotations_code_generation" style="padding-top: 68px; margin-top: -68px;">
						<h3>Phase 3: Code Generation</h3>
						<p>
							A third phase in the lifecycle of the compiler lets you participate in writing and updating the files. In the IDE this phase is only executed on save
							, while the previous two get executed after minor edits in the editor as well. In order to participate your processor needs to implement
							<a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/CodeGenerationParticipant.html"><abbr title="org.eclipse.xtend.lib.macro.CodeGenerationParticipant">CodeGenerationParticipant</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/CodeGenerationParticipant.java">(src)</a>. The extract interface example doesn't make use of this hook, but another example 
							 for internationalization which is also included, generates a *.properties file, like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class ExternalizedProcessor extends AbstractClassProcessor {
  
  ...
  
  override doGenerateCode(List&lt;? extends ClassDeclaration&gt; annotatedSourceElements, extension CodeGenerationContext context) {
    for (clazz : annotatedSourceElements) {
      val filePath = clazz.compilationUnit.filePath
      val file = filePath.targetFolder.append(clazz.qualifiedName.replace('.', '/') + ".properties")
      file.contents = '''
        &laquo;FOR field : clazz.declaredFields&raquo;
          &laquo;field.simpleName&raquo; = &laquo;field.initializerAsString&raquo;
        &laquo;ENDFOR&raquo;
      '''
    }
  }

}</pre>
							<p>
						</p>
						<p>
							The <a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/CodeGenerationContext.html"><abbr title="org.eclipse.xtend.lib.macro.CodeGenerationContext">CodeGenerationContext</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/CodeGenerationContext.java">(src)</a> provides all the services that are available during 
							this phase. Have a look at the Java doc for more details.
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="active_annotations_expression" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">On Expressions and Statements</h2>
						<p>
							Most of the generated Java code is represented in the form of in-memory elements. Basically all the structural elements
							are represented as a dedicated <a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/declaration/Element.html"><abbr title="org.eclipse.xtend.lib.macro.declaration.Element">Element</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/declaration/Element.java">(src)</a>.
							If you want to generate the body of a method or the initializer of a field, you have two options.
						</p>
						<!-- subsection -->
						<section id="active_annotations_compilation_strategies" style="padding-top: 68px; margin-top: -68px;">
						<h3>Generating Blackbox Java Code</h3>
						<p>
							The first option is to assign a compilation strategy and take care of the Java code by yourself. As an example
							the body of a setter method of an observable instance is implemented by the following code snippet:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
observableType.addMethod('set' + fieldName.toFirstUpper) [
  addParameter(fieldName, fieldType)
  body = ['''
    &laquo;fieldType&raquo; _oldValue = this.&laquo;fieldName&raquo;;
    this.&laquo;fieldName&raquo; = &laquo;fieldName&raquo;;
    _propertyChangeSupport.firePropertyChange("&laquo;fieldName&raquo;", _oldValue, &laquo;fieldName&raquo;);
  ''']
]</pre>
							<p>
						</p>
						<p>
							A lambda expression is used to implement the body. This function is invoked later when the actual code is generated.
							It accepts a single parameter which is a <a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/declaration/CompilationStrategy.CompilationContext.html"><abbr title="org.eclipse.xtend.lib.macro.declaration.CompilationStrategy$CompilationContext">CompilationContext</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/declaration/CompilationStrategy.java">(src)</a>.
							The compilation context provides a convenient way write a <a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/declaration/TypeReference.html"><abbr title="org.eclipse.xtend.lib.macro.declaration.TypeReference">TypeReference</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/declaration/TypeReference.java">(src)</a>
							into a Java source file. It takes existing imports into account and adds new imports on the fly if necessary.
						</p>
						</section>
						<!-- subsection -->
						<section id="active_annotations_assigning_expressions" style="padding-top: 68px; margin-top: -68px;">
						<h3>Assigning Expressions</h3>
						<p>
							A second alternative is to put expressions from the Xtend source into the context of a generated Java element.
							This allows to directly use the code that was written in the source file. An 
							annotation <code class="prettyprint lang-xtend">@Lazy</code> which turns fields into lazily initialized properties, may be used like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MyClass {
  @Lazy String myField = expensiveComputation()
}</pre>
							<p>
						</p>
						<p>
							The processor for this <strong>active annotation</strong> could infer a synthetic initializer method
							and add a getter-method, which calls the initializer if the field is still <code class="prettyprint lang-xtend">null</code>. 
							Therefore, the initialization expression of the field has to become the method body of the synthesized initializer method.
							The following code performs this transformation:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
override doTransform(MutableFieldDeclaration field, extension TransformationContext context) {

  // add synthetic init-method
  field.declaringType.addMethod('_init' + field.simpleName) [
    visibility = Visibility.PRIVATE
    returnType = field.type
    // reassign the initializer expression to be the init method's body
    // this automatically removes the expression as the field's initializer
    body = field.initializer
  ]

  // add a getter method which lazily initializes the field
  field.declaringType.addMethod('get' + field.simpleName.toFirstUpper) [
    returnType = field.type
    body = ['''
      if (&laquo;field.simpleName&raquo;==null)
        &laquo;field.simpleName&raquo; = _init&laquo;field.simpleName&raquo;();
      return &laquo;field.simpleName&raquo;;
    ''']
  ]
}</pre>
							<p>
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="active_annotations_validation" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Custom Compiler Checks</h2>
						<p>
							The previous example requires each annotated field to have an initializer. Otherwise it would not be
							possible to use lazy initialization to assign its value. Also a simple check for a <code class="prettyprint lang-xtend">null</code> reference could
							cause trouble with primitive values. A validation for that case would be sensible, too. In order to guide the user dedicated compilation errors should be raised if these constrains are violated.
						</p>
						<p>
							The <a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/TransformationContext.html"><abbr title="org.eclipse.xtend.lib.macro.TransformationContext">TransformationContext</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/TransformationContext.java">(src)</a> inherits methods for exactly that purpose from the <a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/macro/services/ProblemSupport.html"><abbr title="org.eclipse.xtend.lib.macro.services.ProblemSupport">ProblemSupport</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/macro/services/ProblemSupport.java">(src)</a> service.
						</p>
						<p>
							Since the <code class="prettyprint lang-xtend">context</code> is declared as an <a href="#Extension_Provider">extension provider</a>, those methods can be used as extensions and it allows to implement
							the constraint check accordingly:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
override doTransform(MutableFieldDeclaration field, extension TransformationContext context) {
  if (field.type.primitive)
    field.addError("Fields with primitives are not supported by @Lazy")
    
  if (field.initializer == null)
    field.addError("A lazy field must have an initializer.")
  ...
}</pre>
							<p>
						</p>
						<p>
							This ensures that the user is notified about invalid applications of the <strong>active annotation</strong> <code class="prettyprint lang-xtend">@Lazy</code>.
						</p>
						</section>
						<!--  section -->
						<section id="active_annotation_classpath" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Class Path Setup and Testing</h2>
						<p>
							An <strong>active annotation</strong> can not be used in the same project it is declared in, but has to reside on
							an upstream project. Alternatively it can be compiled and deployed in a jar. The annotation and the processor itself only rely
							on the interfaces defined in <code class="prettyprint lang-xtend">org.eclipse.xtend.lib.macro</code> which is part of Xtend's small standard library.
						</p>
						<p>
							When used in an IDE the compiled annotation processor is loaded and executed on the fly within the IDE process.
						</p>
						<p>
							Therefore, careful testing and debugging of the processor is essential. It is best done in a unit test.
							Such a test needs the whole Xtend compiler on the class path, which you can obtain by means of an OSGi bundle dependency or via Maven.
							The maven dependency is
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
&lt;dependency&gt;
  &lt;groupId&gt;org.eclipse.xtend&lt;/groupId&gt;
  &lt;artifactId&gt;org.eclipse.xtend.core&lt;/artifactId&gt;
  &lt;version&gt;2.5.0&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre>
							<p>
						</p>
						<p>
							and the equivalent OSGI bundle is <code class="prettyprint lang-xtend">org.eclipse.xtend.core</code>.
						</p>
						<!-- subsection -->
						<section id="active_annotation_CompilerTester" style="padding-top: 68px; margin-top: -68px;">
						<h3>Testing</h3>
						<p>
							The <code class="prettyprint lang-xtend">XtendCompilerTester</code> is a convenient helper class for testing the processing and the compilation. It allows
							to test active annotation processors by either comparing the generated Java source using a String comparison
							or by inspecting the produced Java elements. In addition you can even compile the generated Java source to a Java
							class and create and test instances of it reflectively.
						</p>
						<p>
							The example project contains a couple of test cases:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class LazyTest {
  extension XtendCompilerTester compilerTester = XtendCompilerTester.newXtendCompilerTester(Lazy)

  @Test def void testLazy() {
    '''
      import lazy.Lazy
      
      class Person {
        @Lazy String name = 'foo'
      }
    '''.assertCompilesTo(
    '''
      import lazy.Lazy;

      @SuppressWarnings("all")
      public class Person {
        @Lazy
        private String name;
        
        private String _initname() {
          return "foo";
        }
        
        public String getName() {
          if (name==null)
            name = _initname();
          return name;
          
        }
      }
    ''')
  }
}</pre>
							<p>
						</p>
						<p>
							This is a basic string comparison. It is a good way to start the development of a new annotation processor.
							Later on assertions against the produced elements and syntax tree (AST) may be a better choice since these are
							not so fragile against changes in the formatting. The <code class="prettyprint lang-xtend">@Extract</code>-example uses this technique:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Test def void testExtractAnnotation() {
  '''
    @extract.Extract
    class MyClass {
      override String doStuff(String myParam) throws IllegalArgumentException {
        return myParam
      }
    }
  '''.compile [
    // declare the transformation context as a local extensions
    val extension ctx = transformationContext
    
    // look up the interface and the class
    val interf = findInterface('MyClassInterface')
    val clazz = findClass('MyClass')
    
    
    // do assertions
    assertEquals(interf, clazz.implementedInterfaces.head.type)
    
    interf.declaredMethods.head =&gt; [
      assertEquals('doStuff', simpleName)
      assertEquals(string, returnType)
      assertEquals(IllegalArgumentException.newTypeReference, exceptions.head)
    ]
  ]
}</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="_24" style="padding-top: 68px; margin-top: -68px;">
						<h3>Wrap Up</h3>
						<p>
							<strong>Active Annotations</strong> are a powerful and unique concept that allows to solve a large class of problems that previously had to be solved in cumbersome ways.
							IDE wizards, many code generators or manually writing boilerplate code are no longer state of the art. Active annotations basically <strong>is</strong> a means of code generation,
							but its simple integration with existing projects and the fast development turn-arounds diminish the typical downsides of code generation.
						</p>
						<p>
							<strong>Important note: The Active Annotation-API as of version 2.5 is provisional, and might be changed and improved in future releases.</strong>
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="_3" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Existing Active Annotations</h2>
						<p>
							Xtend comes with ready-to-use active annotations for common code patterns. 
							They reside in the <code class="prettyprint lang-xtend">org.eclipse.xtend.lib</code> plug-in/jar which must be on the class path of the project containing the Xtend files.
						</p>
						</section>
						<!--  section -->
						<section id="propertyAnnotation" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">@Property</h2>
						<p>
							For fields that are annotated as <a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/Property.html"><code class="prettyprint lang-xtend">@Property</code></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/Property.java">(src)</a>, the Xtend compiler will generate a Java field, a
							getter and, if the field is non-final, a setter method. The name of the Java field will be prefixed with 
							an <code class="prettyprint lang-xtend">_</code> and have the visibility of the Xtend field. The accessor methods are always <code class="prettyprint lang-xtend">public</code>. 
							Thus, an Xtend field
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Property String name</pre>
							<p>
						</p>
						<p>
							will compile to the Java code
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
private String _name;

public String getName() {
  return this._name;
}

public void setName(final String name) {
  this._name = name;
}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="dataAnnotation" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">@Data</h2>
						<p>
							The annotation <a href="http://www.eclipse.org/xtend/api/2.5.0/org/eclipse/xtend/lib/Data.html"><code class="prettyprint lang-xtend">@Data</code></a> <a href="https://github.com/eclipse/xtext/blob/v2.5.0/plugins/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/Data.java">(src)</a>, will turn an annotated class into a value object class. A class annotated with <code class="prettyprint lang-xtend">@Data</code> 
							is processed according to the following rules:
						</p>
						<p>
							</p>
							<ul>
								<li>all fields are final,</li>
								<li>getter methods will be generated (if they do not yet exist),</li>
								<li>a constructor with parameters for all non-initialized fields will be generated (if it does not exist),</li>
								<li>equals(Object) / hashCode() methods will be generated (if they do not exist),</li>
								<li>a toString() method will be generated (if it does not exist).</li>
							</ul>
							<p>
						</p>
						<p>
							Example:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Data class Person {
  String firstName
  String lastName
  
  def static void main(String[] args) {
    val p = new Person(args.get(0), args.get(1))
    println(p.getFirstName() + ' ' + p.lastName)
  }
}</pre>
							<p>
						</p>
						</section>
					</div>
				</div>
			</section>
		</div>
	</div>
</div>
	<div id="extra">
		<div class="inner">
			<div class="container">
				<div class="row">
					<div class="span6">
						<h3 style="padding-top: 0px; margin-top: 0px;">Quick Links</h3>
						<ul class="footer-links clearfix">
							<li><a href="http://www.eclipse.org/legal/privacy.php">Privacy Policy</a></li>
							<li><a href="http://www.eclipse.org/legal/termsofuse.php">Terms of Use</a></li>
							<li><a href="http://www.eclipse.org/legal/copyright.php">Copyright Agent</a></li>
							<li><a href="http://www.eclipse.org/legal/">Legal</a></li>
						</ul>
						<ul class="footer-links clearfix">
	      			<li><a href="http://www.eclipse.org">Eclipse Home</a></li>
							<li><a href="http://marketplace.eclipse.org/">Market Place</a></li>
							<li><a href="http://live.eclipse.org/">Eclipse Live</a></li>
							<li><a href="http://www.planeteclipse.org/">Eclipse Planet</a></li>
						</ul>
					</div>
					<div class="span6">
						<h3 style="padding-top: 0px; margin-top: 0px;"><a href="https://twitter.com/xtendlang" style="color : white;">@Xtendlang</a> on Twitter</h3>
						<a class="twitter-timeline" href="https://twitter.com/xtendlang" data-widget-id="346624176666333185"
						data-chrome="noheader nofooter transparent"
						data-theme="dark">Tweets by @Xtendlang</a>
						<script>
						!function(d,s,id) { 
							var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';
							if(!d.getElementById(id)) { 
							  js=d.createElement(s);
							  js.id=id;
							  js.src=p+"://platform.twitter.com/widgets.js";
							  fjs.parentNode.insertBefore(js,fjs);
							}
						}(document,"script","twitter-wjs");</script>
					</div>
				</div>
			</div>
		</div>
	</div>
	<!-- Le javascript
	    ================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->
	
	<script src="js/bootstrap-transition.js"></script>
	<script src="js/bootstrap-alert.js"></script>
	<script src="js/bootstrap-modal.js"></script>
	<script src="js/bootstrap-dropdown.js"></script>
	<script src="js/bootstrap-scrollspy.js"></script>
	<script src="js/bootstrap-tab.js"></script>
	<script src="js/bootstrap-tooltip.js"></script>
	<script src="js/bootstrap-popover.js"></script>
	<script src="js/bootstrap-button.js"></script>
	<script src="js/bootstrap-collapse.js"></script>
	<script src="js/bootstrap-carousel.js"></script>
	<script src="js/bootstrap-typeahead.js"></script>
	
	<!-- include pretty-print files -->
	<script type="text/javascript" src="google-code-prettify/prettify.js"></script>
	<script type="text/javascript" src="google-code-prettify/lang-xtend.js"></script>
	
	<!-- Include the plug-in -->
	<script src="js/jquery.easing.1.3.js" type="text/javascript"></script>
	<script src="js/custom.js" type="text/javascript"></script>
</body>
</html>
