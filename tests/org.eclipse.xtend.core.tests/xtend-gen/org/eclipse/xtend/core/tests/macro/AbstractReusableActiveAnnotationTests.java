package org.eclipse.xtend.core.tests.macro;

import com.google.common.base.Objects;
import com.google.common.collect.Lists;
import java.util.Collections;
import java.util.List;
import org.eclipse.xtend.core.macro.declaration.CompilationUnitImpl;
import org.eclipse.xtend.core.macro.declaration.TypeLookupImpl;
import org.eclipse.xtend.lib.macro.declaration.MutableAnnotationReference;
import org.eclipse.xtend.lib.macro.declaration.MutableAnnotationTypeDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableConstructorDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableEnumerationTypeDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableInterfaceDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableMethodDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableParameterDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableTypeParameterDeclaration;
import org.eclipse.xtend.lib.macro.declaration.Type;
import org.eclipse.xtend.lib.macro.declaration.TypeReference;
import org.eclipse.xtend.lib.macro.services.Problem;
import org.eclipse.xtend.lib.macro.services.ProblemSupport;
import org.eclipse.xtend.lib.macro.services.TypeReferenceProvider;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function0;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.Pair;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.junit.Assert;
import org.junit.Test;

@SuppressWarnings("all")
public abstract class AbstractReusableActiveAnnotationTests {
  @Test
  public void testAddConstructor() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(AddConstructorProcessor))");
    _builder.newLine();
    _builder.append("annotation AddConstructor{ }");
    _builder.newLine();
    _builder.append("class AddConstructorProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.addConstructor [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("addParameter(\"foo\", string)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/AddConstructorAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AddConstructor class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
        public void apply(final CompilationUnitImpl it) {
          TypeLookupImpl _typeLookup = it.getTypeLookup();
          final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
          Iterable<? extends MutableConstructorDeclaration> _declaredConstructors = clazz.getDeclaredConstructors();
          int _size = IterableExtensions.size(_declaredConstructors);
          Assert.assertEquals(1, _size);
          Iterable<? extends MutableConstructorDeclaration> _declaredConstructors_1 = clazz.getDeclaredConstructors();
          MutableConstructorDeclaration _head = IterableExtensions.head(_declaredConstructors_1);
          List<MutableParameterDeclaration> _parameters = _head.getParameters();
          MutableParameterDeclaration _head_1 = IterableExtensions.<MutableParameterDeclaration>head(_parameters);
          String _simpleName = _head_1.getSimpleName();
          Assert.assertEquals("foo", _simpleName);
        }
      };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAddDefaultConstructor() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.AbstractClassProcessor");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(AddConstructorProcessor))");
    _builder.newLine();
    _builder.append("annotation AddConstructor{ }");
    _builder.newLine();
    _builder.append("class AddConstructorProcessor extends AbstractClassProcessor {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(MutableClassDeclaration clazz, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("clazz.addConstructor [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("body=[\'System.out.println(\"Hello World\");\']");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/AddConstructorAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AddConstructor class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
        public void apply(final CompilationUnitImpl it) {
          TypeLookupImpl _typeLookup = it.getTypeLookup();
          final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
          Iterable<? extends MutableConstructorDeclaration> _declaredConstructors = clazz.getDeclaredConstructors();
          int _size = IterableExtensions.size(_declaredConstructors);
          Assert.assertEquals(1, _size);
          Iterable<? extends MutableConstructorDeclaration> _declaredConstructors_1 = clazz.getDeclaredConstructors();
          MutableConstructorDeclaration _head = IterableExtensions.head(_declaredConstructors_1);
          List<MutableParameterDeclaration> _parameters = _head.getParameters();
          boolean _isEmpty = _parameters.isEmpty();
          Assert.assertTrue(_isEmpty);
        }
      };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testSwapExpressions() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableMethodDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(SwapProcessor))");
    _builder.newLine();
    _builder.append("annotation Swap{ }");
    _builder.newLine();
    _builder.append("class SwapProcessor implements TransformationParticipant<MutableMethodDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableMethodDeclaration> methods, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val b1 = methods.get(0).body");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val b2 = methods.get(1).body");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("methods.get(0).body = b2");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("methods.get(1).body = b1");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/SwapAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Swap def foo(String a) {");
    _builder_1.newLine();
    _builder_1.append("\t\t");
    _builder_1.append("return b");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Swap def bar(String b) {");
    _builder_1.newLine();
    _builder_1.append("\t\t");
    _builder_1.append("return a");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
        public void apply(final CompilationUnitImpl it) {
        }
      };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testSwapExpressions_01() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(SwapProcessor))");
    _builder.newLine();
    _builder.append("annotation Swap{ }");
    _builder.newLine();
    _builder.append("class SwapProcessor implements TransformationParticipant<MutableFieldDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableFieldDeclaration> fields, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val b1 = fields.get(0).initializer");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val b2 = fields.get(1).initializer");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fields.get(0).initializer = b2");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fields.get(1).initializer = b1");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/SwapAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Swap String a = 42");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Swap int b = \'foo\'");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
        public void apply(final CompilationUnitImpl it) {
        }
      };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testSimpleModification() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(AbstractProcessor))");
    _builder.newLine();
    _builder.append("annotation Abstract { }");
    _builder.newLine();
    _builder.append("class AbstractProcessor implements TransformationParticipant<MutableClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableClassDeclaration> annotatedSourceClasses, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedSourceClasses.forEach [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("^abstract = true");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.Abstract");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
        public void apply(final CompilationUnitImpl it) {
          TypeLookupImpl _typeLookup = it.getTypeLookup();
          final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
          boolean _isAbstract = clazz.isAbstract();
          Assert.assertTrue(_isAbstract);
        }
      };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testSetDocumentation() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(AbstractProcessor))");
    _builder.newLine();
    _builder.append("annotation Abstract { }");
    _builder.newLine();
    _builder.append("class AbstractProcessor implements TransformationParticipant<MutableClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableClassDeclaration> annotatedSourceClasses, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedSourceClasses.forEach [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("docComment = docComment.toCharArray.reverse.join");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("/**");
    _builder_1.newLine();
    _builder_1.append(" ");
    _builder_1.append("* dlroW olleH");
    _builder_1.newLine();
    _builder_1.append(" ");
    _builder_1.append("*/");
    _builder_1.newLine();
    _builder_1.append("@myannotation.Abstract");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
        public void apply(final CompilationUnitImpl it) {
          TypeLookupImpl _typeLookup = it.getTypeLookup();
          final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
          String _docComment = clazz.getDocComment();
          Assert.assertEquals("Hello World", _docComment);
        }
      };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testAddAnnotationValue() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableAnnotationTarget");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(AddAnnotationProcessor))");
    _builder.newLine();
    _builder.append("annotation AddAnnotation { }");
    _builder.newLine();
    _builder.append("class AddAnnotationProcessor implements TransformationParticipant<MutableAnnotationTarget> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableAnnotationTarget> annotationTargets, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotationTargets.forEach [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("addAnnotation(typeof(MyAnnotation).findTypeGlobally) => [");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("set(null, \'foo\',\'bar\',\'baz\')");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("set(\'singleValue\', \'foo\')");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("set(\'booleans\', true, false, true)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("set(\'singleBoolean\', true)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("set(\'numbers\', 1,2,3)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("set(\'singleNumber\', 1)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.append("annotation MyAnnotation {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("String[] value");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("String singleValue");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("boolean[] booleans");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("boolean singleBoolean");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("int[] numbers");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("int singleNumber");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.AddAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
        public void apply(final CompilationUnitImpl it) {
          TypeLookupImpl _typeLookup = it.getTypeLookup();
          final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
          TypeReferenceProvider _typeReferenceProvider = it.getTypeReferenceProvider();
          TypeReference _newTypeReference = _typeReferenceProvider.newTypeReference("myannotation.MyAnnotation");
          Type _type = _newTypeReference.getType();
          final MutableAnnotationReference annotation = clazz.findAnnotation(_type);
          Object _value = annotation.getValue("value");
          Assert.assertEquals(Collections.<String>unmodifiableList(Lists.<String>newArrayList("foo", "bar", "baz")), _value);
          Object _value_1 = annotation.getValue("singleValue");
          Assert.assertEquals("foo", _value_1);
          Object _value_2 = annotation.getValue("booleans");
          Assert.assertEquals(Collections.<Boolean>unmodifiableList(Lists.<Boolean>newArrayList(Boolean.valueOf(true), Boolean.valueOf(false), Boolean.valueOf(true))), _value_2);
          Object _value_3 = annotation.getValue("singleBoolean");
          Assert.assertEquals(Boolean.valueOf(true), _value_3);
          Object _value_4 = annotation.getValue("numbers");
          Assert.assertEquals(Collections.<Integer>unmodifiableList(Lists.<Integer>newArrayList(Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3))), _value_4);
          Object _value_5 = annotation.getValue("singleNumber");
          Assert.assertEquals(Integer.valueOf(1), _value_5);
        }
      };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testCreateTypeFromUsage() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.lang.annotation.Documented");
    _builder.newLine();
    _builder.append("import java.lang.annotation.ElementType");
    _builder.newLine();
    _builder.append("import java.lang.annotation.Target");
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MethodDeclaration");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.TypeDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(SomeProcessor))");
    _builder.newLine();
    _builder.append("@Documented");
    _builder.newLine();
    _builder.append("@Target(ElementType::TYPE)");
    _builder.newLine();
    _builder.append("annotation SomeAnnotation {}");
    _builder.newLine();
    _builder.append("class SomeProcessor implements RegisterGlobalsParticipant<TypeDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(List<? extends TypeDeclaration> types, RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("types.forEach[");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("declaredMethods.forEach[");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("context.registerClass(parameterType)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private def getParameterType(MethodDeclaration it) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("parameters.head.type.type.qualifiedName");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/SomeAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.SomeAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def void myMethod(DoesNotExist p) {}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
        public void apply(final CompilationUnitImpl it) {
          TypeLookupImpl _typeLookup = it.getTypeLookup();
          MutableClassDeclaration _findClass = _typeLookup.findClass("myusercode.DoesNotExist");
          String _simpleName = _findClass.getSimpleName();
          boolean _equals = Objects.equal(_simpleName, "DoesNotExist");
          Assert.assertTrue(_equals);
        }
      };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testPropertyAnnotation() {
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/PropertyAnnotation.xtend", "\n\t\t\t\tpackage myannotation\n\t\t\t\t\n\t\t\t\timport java.util.List\n\t\t\t\timport org.eclipse.xtend.lib.macro.Active\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationContext\n\t\t\t\timport org.eclipse.xtend.lib.macro.TransformationParticipant\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration\n\t\t\t\timport org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration\n\n\t\t\t\t@Active(typeof(PropertyProcessor))\n\t\t\t\tannotation Property2 { }\n\t\t\t\tclass PropertyProcessor implements TransformationParticipant<MutableFieldDeclaration> {\n\t\t\t\t\t\n\t\t\t\t\toverride doTransform(List<? extends MutableFieldDeclaration> annotatedTargetFields, extension TransformationContext context) {\n\t\t\t\t\t\tannotatedTargetFields.forEach [ field |\n\t\t\t\t\t\t\tval declaringType = field.declaringType \n\t\t\t\t\t\t\tdeclaringType.addMethod(field.getterName) [\n\t\t\t\t\t\t\t\treturnType = field.type\n\t\t\t\t\t\t\t\tbody = [\'\'\'\n\t\t\t\t\t\t\t\t\treturn this.\u00ABfield.simpleName\u00BB;\n\t\t\t\t\t\t\t\t\'\'\']\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\tdeclaringType.addMethod(\'set\'+field.simpleName.toFirstUpper) [\n\t\t\t\t\t\t\t\taddParameter(field.simpleName, field.type)\n\t\t\t\t\t\t\t\tbody = [\'\'\'\n\t\t\t\t\t\t\t\t\tthis.\u00ABfield.simpleName\u00BB = \u00ABfield.simpleName\u00BB;\n\t\t\t\t\t\t\t\t\'\'\']\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdef private String getterName(MutableFieldDeclaration field) {\n\t\t\t\t\t\treturn \'get\'+field.simpleName.toFirstUpper\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t");
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myusercode");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@myannotation.Property2 String myField");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
        public void apply(final CompilationUnitImpl it) {
          TypeLookupImpl _typeLookup = it.getTypeLookup();
          final MutableClassDeclaration clazz = _typeLookup.findClass("myusercode.MyClass");
          Iterable<? extends MutableMethodDeclaration> _declaredMethods = clazz.getDeclaredMethods();
          final MutableMethodDeclaration getter = IterableExtensions.head(_declaredMethods);
          String _simpleName = getter.getSimpleName();
          Assert.assertEquals("getMyField", _simpleName);
          TypeReference _returnType = getter.getReturnType();
          String _string = _returnType.toString();
          Assert.assertEquals("String", _string);
          TypeReference _returnType_1 = getter.getReturnType();
          final MutableMethodDeclaration setter = clazz.findMethod("setMyField", _returnType_1);
          String _simpleName_1 = setter.getSimpleName();
          Assert.assertEquals("setMyField", _simpleName_1);
          TypeReference _returnType_2 = setter.getReturnType();
          String _string_1 = _returnType_2.toString();
          Assert.assertEquals("void", _string_1);
          List<MutableParameterDeclaration> _parameters = setter.getParameters();
          MutableParameterDeclaration _head = IterableExtensions.<MutableParameterDeclaration>head(_parameters);
          String _simpleName_2 = _head.getSimpleName();
          Assert.assertEquals("myField", _simpleName_2);
          List<MutableParameterDeclaration> _parameters_1 = setter.getParameters();
          MutableParameterDeclaration _head_1 = IterableExtensions.<MutableParameterDeclaration>head(_parameters_1);
          TypeReference _type = _head_1.getType();
          String _string_2 = _type.toString();
          Assert.assertEquals("String", _string_2);
        }
      };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testThrowsAndTypeParam() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableMethodDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(ThrowsAndTypeParamProcessor))");
    _builder.newLine();
    _builder.append("annotation ThrowsAndTypeParam { }");
    _builder.newLine();
    _builder.append("class ThrowsAndTypeParamProcessor implements TransformationParticipant<MutableMethodDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableMethodDeclaration> annotatedMethods, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedMethods.forEach [");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("val type = addTypeParameter(\'A\')");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("addParameter(\'myParam\', newTypeReference(type))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setExceptions(newTypeReference(\'java.lang.Exception\'))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.ThrowsAndTypeParam");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def void foo(){");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
        public void apply(final CompilationUnitImpl it) {
          TypeLookupImpl _typeLookup = it.getTypeLookup();
          final MutableClassDeclaration type = _typeLookup.findClass("myusercode.MyClass");
          Iterable<? extends MutableMethodDeclaration> _declaredMethods = type.getDeclaredMethods();
          final MutableMethodDeclaration method = IterableExtensions.head(_declaredMethods);
          List<MutableTypeParameterDeclaration> _typeParameters = method.getTypeParameters();
          MutableTypeParameterDeclaration _head = IterableExtensions.<MutableTypeParameterDeclaration>head(_typeParameters);
          String _simpleName = _head.getSimpleName();
          Assert.assertEquals("A", _simpleName);
          List<MutableParameterDeclaration> _parameters = method.getParameters();
          MutableParameterDeclaration _head_1 = IterableExtensions.<MutableParameterDeclaration>head(_parameters);
          String _simpleName_1 = _head_1.getSimpleName();
          Assert.assertEquals("myParam", _simpleName_1);
          List<MutableTypeParameterDeclaration> _typeParameters_1 = method.getTypeParameters();
          MutableTypeParameterDeclaration _head_2 = IterableExtensions.<MutableTypeParameterDeclaration>head(_typeParameters_1);
          List<MutableParameterDeclaration> _parameters_1 = method.getParameters();
          MutableParameterDeclaration _head_3 = IterableExtensions.<MutableParameterDeclaration>head(_parameters_1);
          TypeReference _type = _head_3.getType();
          Type _type_1 = _type.getType();
          Assert.assertSame(_head_2, _type_1);
          List<TypeReference> _exceptions = method.getExceptions();
          int _size = _exceptions.size();
          Assert.assertEquals(1, _size);
        }
      };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testValidation() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableNamedElement");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(ValidatedProcessor))");
    _builder.newLine();
    _builder.append("annotation Validated { }");
    _builder.newLine();
    _builder.append("class ValidatedProcessor implements TransformationParticipant<MutableNamedElement> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doTransform(List<? extends MutableNamedElement> annotatedMethods, extension TransformationContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("annotatedMethods.forEach [ ele |");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("switch ele {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("MutableFieldDeclaration : ele.addWarning(\'field-warning\')");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("default : ele.addWarning(\'warning\')");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/AbstractAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Validated");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("def void foo() {");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("@myannotation.Validated");
    _builder_1.newLine();
    _builder_1.append("\t");
    _builder_1.append("String name");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
        public void apply(final CompilationUnitImpl it) {
          TypeLookupImpl _typeLookup = it.getTypeLookup();
          final MutableClassDeclaration type = _typeLookup.findClass("myusercode.MyClass");
          Iterable<? extends MutableMethodDeclaration> _declaredMethods = type.getDeclaredMethods();
          final MutableMethodDeclaration method = IterableExtensions.head(_declaredMethods);
          Iterable<? extends MutableFieldDeclaration> _declaredFields = type.getDeclaredFields();
          final MutableFieldDeclaration field = IterableExtensions.head(_declaredFields);
          ProblemSupport _problemSupport = it.getProblemSupport();
          List<Problem> _problems = _problemSupport.getProblems(field);
          Problem _head = IterableExtensions.<Problem>head(_problems);
          String _message = _head.getMessage();
          Assert.assertEquals("field-warning", _message);
          ProblemSupport _problemSupport_1 = it.getProblemSupport();
          List<Problem> _problems_1 = _problemSupport_1.getProblems(method);
          Problem _head_1 = IterableExtensions.<Problem>head(_problems_1);
          String _message_1 = _head_1.getMessage();
          Assert.assertEquals("warning", _message_1);
        }
      };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  @Test
  public void testIntroduceNewTypes() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package myannotation");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.List");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.Active");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsContext");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant");
    _builder.newLine();
    _builder.append("import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration");
    _builder.newLine();
    _builder.newLine();
    _builder.append("@Active(typeof(NewTypesAddingAnnotationProcessor))");
    _builder.newLine();
    _builder.append("annotation NewTypesAddingAnnotation { }");
    _builder.newLine();
    _builder.append("class NewTypesAddingAnnotationProcessor implements RegisterGlobalsParticipant<ClassDeclaration> {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("override doRegisterGlobals(List<? extends ClassDeclaration> sourceClasses, RegisterGlobalsContext context) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (clazz : sourceClasses) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("context.registerClass(clazz.qualifiedName+\".InnerClass\")");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("context.registerInterface(clazz.qualifiedName+\"Interface\")");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("context.registerEnumerationType(clazz.qualifiedName+\"Enum\")");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("context.registerAnnotationType(clazz.qualifiedName+\"Annotation\")");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("myannotation/NewTypesAddingAnnotation.xtend", _builder.toString());
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("package myusercode");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("@myannotation.NewTypesAddingAnnotation");
    _builder_1.newLine();
    _builder_1.append("class MyClass {");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    Pair<String,String> _mappedTo_1 = Pair.<String, String>of("myusercode/UserCode.xtend", _builder_1.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
        public void apply(final CompilationUnitImpl it) {
          TypeLookupImpl _typeLookup = it.getTypeLookup();
          MutableClassDeclaration _findClass = _typeLookup.findClass("myusercode.MyClass");
          Assert.assertNotNull(_findClass);
          TypeLookupImpl _typeLookup_1 = it.getTypeLookup();
          MutableClassDeclaration _findClass_1 = _typeLookup_1.findClass("myusercode.MyClass.InnerClass");
          Assert.assertNotNull(_findClass_1);
          TypeLookupImpl _typeLookup_2 = it.getTypeLookup();
          MutableInterfaceDeclaration _findInterface = _typeLookup_2.findInterface("myusercode.MyClassInterface");
          Assert.assertNotNull(_findInterface);
          TypeLookupImpl _typeLookup_3 = it.getTypeLookup();
          MutableEnumerationTypeDeclaration _findEnumerationType = _typeLookup_3.findEnumerationType("myusercode.MyClassEnum");
          Assert.assertNotNull(_findEnumerationType);
          TypeLookupImpl _typeLookup_4 = it.getTypeLookup();
          MutableAnnotationTypeDeclaration _findAnnotationType = _typeLookup_4.findAnnotationType("myusercode.MyClassAnnotation");
          Assert.assertNotNull(_findAnnotationType);
        }
      };
    this.assertProcessing(_mappedTo, _mappedTo_1, _function);
  }
  
  private final Pair<String,String> THREE_ANNOTATIONS = new Function0<Pair<String,String>>() {
    public Pair<String,String> apply() {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("import java.util.List");
      _builder.newLine();
      _builder.append("import org.eclipse.xtend.lib.macro.Active");
      _builder.newLine();
      _builder.append("import org.eclipse.xtend.lib.macro.TransformationContext");
      _builder.newLine();
      _builder.append("import org.eclipse.xtend.lib.macro.TransformationParticipant");
      _builder.newLine();
      _builder.append("import org.eclipse.xtend.lib.macro.declaration.MutableNamedElement");
      _builder.newLine();
      _builder.newLine();
      _builder.append("@Active(typeof(Aprocessor))");
      _builder.newLine();
      _builder.append("annotation _A {}");
      _builder.newLine();
      _builder.append("class Aprocessor implements TransformationParticipant<MutableNamedElement> {");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("override doTransform(List<? extends MutableNamedElement> annotatedTargetElements, extension TransformationContext context) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("annotatedTargetElements.forEach[");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("simpleName = simpleName + num()");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("]");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def num() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("\'_A\'");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.append("@Active(typeof(Bprocessor))");
      _builder.newLine();
      _builder.append("annotation _B {}");
      _builder.newLine();
      _builder.append("class Bprocessor extends Aprocessor {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("override num() { \'_B\' }");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("@Active(typeof(Cprocessor))");
      _builder.newLine();
      _builder.append("annotation _C {}");
      _builder.newLine();
      _builder.append("class Cprocessor extends Aprocessor {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("override num() { \'_C\' }");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      Pair<String,String> _mappedTo = Pair.<String, String>of("three.xtend", _builder.toString());
      return _mappedTo;
    }
  }.apply();
  
  @Test
  public void testDeterministicExecutionOrder_01() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@_A @_B @_C String field");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("MyClass.xtend", _builder.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
        public void apply(final CompilationUnitImpl it) {
          TypeLookupImpl _typeLookup = it.getTypeLookup();
          final MutableClassDeclaration myClass = _typeLookup.findClass("MyClass");
          Iterable<? extends MutableFieldDeclaration> _declaredFields = myClass.getDeclaredFields();
          MutableFieldDeclaration _head = IterableExtensions.head(_declaredFields);
          String _simpleName = _head.getSimpleName();
          Assert.assertEquals("field_A_B_C", _simpleName);
        }
      };
    this.assertProcessing(this.THREE_ANNOTATIONS, _mappedTo, _function);
  }
  
  @Test
  public void testDeterministicExecutionOrder_02() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("class MyClass {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@_A @_B @_C String field1");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@_C @_B @_A String field2");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("MyClass.xtend", _builder.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
        public void apply(final CompilationUnitImpl it) {
          TypeLookupImpl _typeLookup = it.getTypeLookup();
          final MutableClassDeclaration myClass = _typeLookup.findClass("MyClass");
          Iterable<? extends MutableFieldDeclaration> _declaredFields = myClass.getDeclaredFields();
          MutableFieldDeclaration _head = IterableExtensions.head(_declaredFields);
          String _simpleName = _head.getSimpleName();
          Assert.assertEquals("field1_A_B_C", _simpleName);
          Iterable<? extends MutableFieldDeclaration> _declaredFields_1 = myClass.getDeclaredFields();
          MutableFieldDeclaration _get = ((MutableFieldDeclaration[])Conversions.unwrapArray(_declaredFields_1, MutableFieldDeclaration.class))[1];
          String _simpleName_1 = _get.getSimpleName();
          Assert.assertEquals("field2_A_B_C", _simpleName_1);
        }
      };
    this.assertProcessing(this.THREE_ANNOTATIONS, _mappedTo, _function);
  }
  
  @Test
  public void testDeterministicExecutionOrder_03() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("@_A @_B @_C class MyClass {");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    Pair<String,String> _mappedTo = Pair.<String, String>of("MyClass.xtend", _builder.toString());
    final Procedure1<CompilationUnitImpl> _function = new Procedure1<CompilationUnitImpl>() {
        public void apply(final CompilationUnitImpl it) {
          TypeLookupImpl _typeLookup = it.getTypeLookup();
          final MutableClassDeclaration myClass = _typeLookup.findClass("MyClass_A_B_C");
          Assert.assertNotNull(myClass);
        }
      };
    this.assertProcessing(this.THREE_ANNOTATIONS, _mappedTo, _function);
  }
  
  public abstract void assertProcessing(final Pair<String,String> macroFile, final Pair<String,String> clientFile, final Procedure1<? super CompilationUnitImpl> expectations);
}
