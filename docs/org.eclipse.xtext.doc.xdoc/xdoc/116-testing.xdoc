section:testing[Unit Testing the Language]

Automated tests are crucial for the maintainability and the quality of a software product. That is why
it is strongly recommended to write unit tests for your language, too. The Xtext project wizard creates
a test project for that purpose. It simplifies the setup procedure both for the Eclipse agnostic tests and the UI
tests for Junit4.

The following is about testing the parser and the linker for the e[Domainmodel] language from the tutorial. It leverages Xtend to
write the test case.

section2[Creating a simple test class]

First of all, a new Xtend class has to be created. Therefore, choose the src folder of the test 
plugin, and select e[New -> Xtend Class] from the context menu. Provide a meaningful name and
enter the package before you hit finish.

The core of the test infrastructure is the codeRef[org.eclipse.xtext.junit4.XtextRunner] and
the language specific codeRef[org.eclipse.xtext.junit4.IInjectorProvider]. Both have to be provided
by means of class annotations:
 
code[Xtend][
  import org.eclipse.xtext.junit4.XtextRunner
  import org.example.domainmodel.DomainmodelInjectorProvider
  
  @InjectWith(DomainmodelInjectorProvider)
  @RunWith(XtextRunner)
  class ParserTest {
  }
]

This configuration will make sure that you can use dependency injection in your test class, and that the global EMF registries
are properly populated and cleaned up before respectively after each test. 

section2[Writing a parser test]

The class e[org.eclipse.xtext.junit4.util.ParseHelper] allows to parse an arbitrary string into an
AST model. The AST model itself can be traversed and checked afterwards. A static import of
codeRef[org.junit.Assert] leads to concise and readable test cases.

code[Xtend][
  import org.eclipse.xtext.junit4.util.ParseHelper
  import static org.junit.Assert.*
  
  ...

  @Inject
  ParseHelper<Domainmodel> parser
  
  @Test 
  def void parseDomainmodel() {
    val model = parser.parse('''
      entity MyEntity {
        parent: MyEntity
      }
    ''')
    val entity = model.elements.head as Entity
    assertSame(entity, entity.features.head.type)
  }
]

section2[How to write tests that includes multiple different languages]

If in addition to the main language your tests require using other languages for references from/to your main language,
you'll have to parse and load dependant resources into the same ResourceSet first for cross reference resolution to work.

As your main language's default generated codeRef[org.eclipse.xtext.junit4.IInjectorProvider] (e.g. DomainmodelInjectorProvider) does not know about
any other such dependant languages, they must be initialized explicitly. The recommended pattern for this is to
create a new subclass of the generated e[MyLanguageInjectorProvider] in your e[*.test] project and make sure the dependenant 
language is intizialized properly. You can and then use this new injector provider instead of the original one in your test's e[@InjectWith]:

code[Xtend][
  class MyLanguageWithDependenciesInjectorProvider extends MyLanguageInjectorProvider {
    override internalCreateInjector() {
      MyOtherLangLanguageStandaloneSetup.doSetup
      return super.internalCreateInjector
    }
  }
  
  @RunWith(XtextRunner)
  @InjectWith(MyLanguageWithDependenciesInjectorProvider)
  class YourTest {
    ...
  }
]

You should not put injector creation for referenced languages in your standalone setup. Note that for the headless code generation use case,
the Maven plug-in is configured with multiple setups, so usually there is no problem there.

You may also need to initialize 'import'-ed ecore models that are not generated by your Xtext language. This should be done by using
an explicit e[MyModelPackage.eINSTANCE.getName();] in the e[doSetup()] method of your respective language's StandaloneSetup class. 
Note that it is strongly recommended to follow this pattern instead of just using e[@Before] methods in your
*Test class, as due to internal technical reasons that won't work anymore as soon as you have more than just one e[@Test].

code[Xtend][
  class MyLanguageStandaloneSetup extends MyLanguageStandaloneSetupGenerated {
  
    def static void doSetup() {
      MyPackageImpl.init
      new MyLanguageStandaloneSetup().createInjectorAndDoEMFRegistration
    }
  
  }
]

This only applies to referencing dependencies to 'import'-ed Ecore models and languages based on them which may be used in the test.
The inherited dependencies from mixed-in grammars are automatically listed in the generated super class already, and nothing needs to be done for those.

