section:TutorialUnitTests[Unit Testing the Language]

Automated tests are crucial for the maintainability and the quality of a software product. That is why
it is strongly recommended to write unit tests for your language, too. The Xtext project wizard creates
a test project for that purpose. It simplifies the setup procedure both for the Eclipse agnostic tests and the UI
tests for Junit4.

This tutorial is about testing the parser and the linker for the e[Domainmodel]. It leverages Xtend to
write the test case.

ol[
  item[
    First of all, a new Xtend class has to be created. Therefore, choose the src folder of the test
    plugin, and select e[New -> Xtend Class] from the context menu. Provide a meaningful name and
    enter the package before you hit finish.
    
    The core of the test infrastructure is the codeRef[org.eclipse.xtext.junit4.XtextRunner] and
    the language specific codeRef[org.eclipse.xtext.junit4.IInjectorProvider]. Both have to be provided
    by means of class annotations:  
 
    code[Xtend][
      import org.eclipse.xtext.junit4.XtextRunner
      import org.example.domainmodel.DomainmodelInjectorProvider
      
      @InjectWith(DomainmodelInjectorProvider)
      @RunWith(XtextRunner)
      class ParserTest {
      }
    ]
  ]
  item[
    The actual test case is pretty straight forward with Xtend. The utility class 
    e[org.eclipse.xtext.junit4.util.ParseHelper] allows to parse an arbitrary string into a
    e[Domainmodel]. The model itself can be traversed and checked afterwards. A static import of
    codeRef[org.junit.Assert] leads to concise and readable test cases.
    
    code[Xtend][
      import org.eclipse.xtext.junit4.util.ParseHelper
      import static org.junit.Assert.*
      
      ...
    
      @Inject
      ParseHelper<Domainmodel> parser
      
      @Test 
      def void parseDomainmodel() {
        val model = parser.parse(
          "entity MyEntity {
            parent: MyEntity
          }")
        val entity = model.elements.head as Entity
        assertSame(entity, entity.features.head.type)
      }
    ]
  ]
  item[
    After saving the Xtend file, it is time to run the test. Select e[Run As -> JUnit Test] from the editor's context menu.
  ]
  item[
    If in addition to the main language your tests require using other languages for references from/to your main language,
    you'll have to parse and load dependant resources into the same ResourceSet first for cross reference resolution to work.

    As your main language's default generated IInjectorProvider (e.g. DomainmodelInjectorProvider) does not know about
    any other such "dependant" languages, they must be initialized explicitly.  The recommended pattern for this is to
    create a new subclass of the generated MyLanguageInjectorProvider in your *.test project, by convention named
    MyLanguageWithDependenciesInjectorProvider, and inserting MyOtherLangLanguageStandaloneSetup().doSetup()
    before return super.internalCreateInjector() in an @Overide internalCreateInjector().  You can and then use
    this new MyLanguageWithDependenciesInjectorProvider instead of the original MyLanguageInjectorProvider in your Test's @InjectWith:

    code[Java][
       public class MyLanguageWithDependenciesInjectorProvider extends MyLanguageInjectorProvider {

        @Override
        protected Injector internalCreateInjector() {
          MyOtherLangLanguageStandaloneSetup.doSetup();

          return super.internalCreateInjector();
        }
      }

      @RunWith(XtextRunner.class)
      @InjectWith(MyLanguageWithDependenciesInjectorProvider.class)
      public class YourTest {
        ...
    ]

    You should not put injector creation for referenced languages in your standalone setup. Note that for the headless code generation use case,
    the Maven plug-in is configured with multiple setups, so usually there is no problem there.

    You may also need to initialize 'import'-ed ecore models that are not generated by your Xtext language. This should be done by using
    an explicit MyModelPackage.eINSTANCE.getName(); in the doSetup() method of your respective language's *StandaloneSetup (not in the
    *InjectorProvider) class. Note that it is strongly recommended to follow this pattern instead of just using @Before methods in your
    *Test class, as due to internal technical reasons that won't work anymore as soon as you have more than just one @Test.

    code[Java][
      public class MyLanguageStandaloneSetup extends MyLanguageStandaloneSetupGenerated {

      ...

        public static void doSetup() {
          MyPackageImpl.init();
          new MyLanguageStandaloneSetup().createInjectorAndDoEMFRegistration();
	}
    ]

    This only applies to "horizontal dependencies" to 'import'-ed Ecore models and languages based on them which may be used in the test.
    The "vertical hierarchical dependencies" from mixed-in reused existing 'with' parent grammars are automatically listed in the lang's
    src-gen/*StandaloneSetupGenerated class already, and nothing needs to be done for those.
  ]
]

