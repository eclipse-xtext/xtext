/*
* generated by Xtext
*/
package org.eclipse.xtend.ide.outline;

import static com.google.common.collect.Iterables.*;
import static com.google.common.collect.Lists.*;
import static com.google.common.collect.Sets.*;
import static java.util.Collections.*;

import java.util.Comparator;
import java.util.List;
import java.util.Set;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.jdt.ui.JavaElementImageDescriptor;
import org.eclipse.jface.resource.ImageDescriptor;
import org.eclipse.jface.viewers.StyledString;
import org.eclipse.xtend.core.jvmmodel.DispatchHelper;
import org.eclipse.xtend.core.jvmmodel.IXtendJvmAssociations;
import org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer;
import org.eclipse.xtend.core.xtend.XtendClass;
import org.eclipse.xtend.core.xtend.XtendFile;
import org.eclipse.xtend.core.xtend.XtendFunction;
import org.eclipse.xtend.ide.labeling.XtendImages;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.common.types.JvmConstructor;
import org.eclipse.xtext.common.types.JvmDeclaredType;
import org.eclipse.xtext.common.types.JvmFeature;
import org.eclipse.xtext.common.types.JvmGenericType;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.common.types.JvmTypeReference;
import org.eclipse.xtext.common.types.TypesPackage;
import org.eclipse.xtext.ui.editor.outline.IOutlineNode;
import org.eclipse.xtext.ui.editor.outline.impl.DocumentRootNode;
import org.eclipse.xtext.ui.editor.outline.impl.EObjectNode;
import org.eclipse.xtext.xbase.jvmmodel.JvmTypeExtensions;
import org.eclipse.xtext.xbase.ui.labeling.XbaseImageAdornments;
import org.eclipse.xtext.xtype.XtypePackage;

import com.google.inject.Inject;

/**
 * Customization of the default outline structure.
 * 
 * @author Dennis Huebner
 */
public class XtendOutlineJvmTreeProvider extends AbstractMultiModeOutlineTreeProvider {

	@Inject
	private XtendImages images;

	@Inject
	private XbaseImageAdornments adornments;

	@Inject
	private IXtendJvmAssociations associations;

	@Inject
	private DispatchHelper dispatchHelper;

	@Inject
	private JvmTypeExtensions typeExtensions;

	@Override
	public void internalCreateChildren(DocumentRootNode parentNode, EObject modelElement) {

		EList<EObject> contents = modelElement.eResource().getContents();
		String primaryPackage = null;
		for (EObject eObject : contents) {
			if (eObject instanceof JvmDeclaredType) {
				JvmDeclaredType jvmDeclaredType = (JvmDeclaredType) eObject;
				String packageName = jvmDeclaredType.getPackageName();
				EObject sourceElement = associations.getPrimarySourceElement(jvmDeclaredType);
				if (packageName != null && sourceElement instanceof XtendClass) {
					XtendFile xtendFile = EcoreUtil2.getContainerOfType(sourceElement, XtendFile.class);
					if (xtendFile != null && primaryPackage == null) {
						getOutlineNodeFactory().createEStructuralFeatureNode(parentNode, jvmDeclaredType,
								TypesPackage.Literals.JVM_DECLARED_TYPE__PACKAGE_NAME, images.forPackage(),
								packageName, true);
						if (xtendFile.getImportSection() != null
								&& !xtendFile.getImportSection().getImportDeclarations().isEmpty()) {
							getOutlineNodeFactory().createEStructuralFeatureNode(parentNode,
									xtendFile.getImportSection(),
									XtypePackage.Literals.XIMPORT_SECTION__IMPORT_DECLARATIONS,
									images.forImportContainer(), "import declarations", false);
						}
						primaryPackage = packageName;
					}
				}
				EObjectNode typeNode = createNodeForType(parentNode, jvmDeclaredType);
				if (packageName != null && !packageName.equals(primaryPackage)) {
					Object text = typeNode.getText();
					if (text instanceof StyledString) {
						typeNode.setText(((StyledString) text).append(new StyledString(" - " + packageName,
								StyledString.DECORATIONS_STYLER)));
					}
				}
			}
		}
	}

	private EObjectNode createNodeForType(IOutlineNode parentNode, JvmDeclaredType typeElement) {
		EObjectNode classNode = createNode(parentNode, typeElement);
		Set<JvmFeature> processedFeatures = newHashSet();
		createFeatureNodesForType(classNode, typeElement, typeElement, processedFeatures, 0);
		return classNode;
	}

	private void createFeatureNodesForType(IOutlineNode parentNode, JvmDeclaredType inferredType,
			final JvmDeclaredType baseType, Set<JvmFeature> processedFeatures, int inheritanceDepth) {
		for (JvmDeclaredType nestedType : filter(inferredType.getMembers(), JvmDeclaredType.class))
			createNodeForType(parentNode, nestedType);
		for (JvmOperation operation : inferredType.getDeclaredOperations()) {
			if (dispatchHelper.isDispatcherFunction(operation)) {
				JvmOperation dispatcher = operation;
				XtendFeatureNode dispatcherNode = createNodeForFeature(parentNode, baseType, dispatcher, dispatcher,
						inheritanceDepth);
				if (dispatcherNode != null) {
					dispatcherNode.setDispatch(true);
					addJvmFeature(processedFeatures, dispatcher);
					boolean inheritsDispatchCases = false;
					Iterable<JvmOperation> dispatchCases;
					if (getCurrentMode() == SHOW_INHERITED_MODE)
						dispatchCases = dispatchHelper.getAllDispatchCases(dispatcher);
					else {
						dispatchCases = newArrayList(dispatchHelper.getLocalDispatchCases(dispatcher));
						sort((List<JvmOperation>) dispatchCases, new Comparator<JvmOperation>() {
							public int compare(JvmOperation o1, JvmOperation o2) {
								return baseType.getMembers().indexOf(o1) - baseType.getMembers().indexOf(o2);
							}
						});
					}
					for (JvmOperation dispatchCase : dispatchCases) {
						inheritsDispatchCases |= dispatchCase.getDeclaringType() != baseType;
						XtendFunction xtendFunction = associations.getXtendFunction(dispatchCase);
						if (xtendFunction == null) {
							createNodeForFeature(dispatcherNode, baseType, dispatchCase, dispatchCase, inheritanceDepth);
						} else {
							createNodeForFeature(dispatcherNode, baseType, dispatchCase, xtendFunction,
									inheritanceDepth);
						}
						addJvmFeature(processedFeatures, dispatchCase);
					}
					if (inheritsDispatchCases)
						dispatcherNode.setImageDescriptor(images.forDispatcherFunction(dispatcher.getVisibility(),
								adornments.get(dispatcher) | JavaElementImageDescriptor.OVERRIDES));
				}
			}
		}
		for (JvmFeature feature : filter(inferredType.getMembers(), JvmFeature.class)) {
			if (!processedFeatures.contains(feature)) {
				EObject primarySourceElement = associations.getPrimarySourceElement(feature);
				if (feature instanceof JvmConstructor && feature.getDeclaringType().isLocal()) {
					continue;
				}
				IOutlineNode featureNode = createNodeForFeature(parentNode, baseType, feature,
						primarySourceElement != null ? primarySourceElement : feature, inheritanceDepth);
				EList<JvmGenericType> localClasses = feature.getLocalClasses();
				if (!localClasses.isEmpty()) {
					for (JvmGenericType jvmGenericType : localClasses) {
						createNodeForType(featureNode, jvmGenericType);
					}
				}
				addJvmFeature(processedFeatures, feature);
			}
		}
		if (getCurrentMode() == SHOW_INHERITED_MODE) {
			if (inferredType instanceof JvmGenericType) {
				JvmTypeReference extendedClass = ((JvmGenericType) inferredType).getExtendedClass();
				if (extendedClass != null)
					createInheritedFeatureNodes(parentNode, baseType, processedFeatures, inheritanceDepth,
							extendedClass);
				for (JvmTypeReference extendedInterface : ((JvmGenericType) inferredType).getExtendedInterfaces()) {
					createInheritedFeatureNodes(parentNode, baseType, processedFeatures, inheritanceDepth,
							extendedInterface);
				}
			}
		}
	}

	private void addJvmFeature(Set<JvmFeature> processedFeatures, JvmFeature feature) {
		processedFeatures.add(feature);
		addCreateExtensionJvmFeatures(processedFeatures, feature);
	}

	private void addCreateExtensionJvmFeatures(Set<JvmFeature> processedFeatures, JvmFeature feature) {
		EObject sourceElement = associations.getPrimarySourceElement(feature);
		if (!(sourceElement instanceof XtendFunction)) {
			return;
		}
		XtendFunction function = (XtendFunction) sourceElement;
		if (function.getCreateExtensionInfo() == null) {
			return;
		}
		for (EObject jvmElement : associations.getJvmElements(function)) {
			if (jvmElement == feature || !(jvmElement instanceof JvmFeature)) {
				continue;
			}
			JvmFeature jvmFeature = (JvmFeature) jvmElement;
			if (jvmFeature.getSimpleName().startsWith(XtendJvmModelInferrer.CREATE_CHACHE_VARIABLE_PREFIX)) {
				processedFeatures.add(jvmFeature);
			}
			if (jvmFeature.getSimpleName().startsWith(XtendJvmModelInferrer.CREATE_INITIALIZER_PREFIX)) {
				processedFeatures.add(jvmFeature);
			}
		}
	}

	private void createInheritedFeatureNodes(IOutlineNode parentNode, JvmDeclaredType baseType,
			Set<JvmFeature> processedFeatures, int inheritanceDepth, JvmTypeReference superType) {
		if (superType.getType() instanceof JvmDeclaredType) {
			JvmDeclaredType superClass = ((JvmGenericType) superType.getType());
			createFeatureNodesForType(parentNode, superClass, baseType, processedFeatures, inheritanceDepth + 1);
		}
	}

	private XtendFeatureNode createNodeForFeature(IOutlineNode parentNode, final JvmDeclaredType inferredType,
			JvmFeature jvmFeature, EObject semanticFeature, int inheritanceDepth) {
		final boolean synthetic = typeExtensions.isSynthetic(jvmFeature);
		Object text = getText(synthetic ? jvmFeature : semanticFeature);
		ImageDescriptor image = getImageDescriptor(synthetic ? jvmFeature : semanticFeature);
		if (jvmFeature.getDeclaringType() != inferredType) {
			if (getCurrentMode() == SHOW_INHERITED_MODE) {
				StyledString label = (text instanceof StyledString) ? (StyledString) text : new StyledString(
						text.toString());
				label.append(new StyledString(" - " + jvmFeature.getDeclaringType().getIdentifier(),
						StyledString.QUALIFIER_STYLER));
				return getOutlineNodeFactory().createXtendFeatureNode(parentNode, jvmFeature, image, label, true,
						synthetic, inheritanceDepth);
			}
			return null;
		} else {
			return getOutlineNodeFactory().createXtendFeatureNode(parentNode, semanticFeature, image, text, true,
					synthetic, inheritanceDepth);
		}
	}

	@Override
	protected boolean isLeaf(EObject modelElement) {
		if (modelElement instanceof JvmDeclaredType) {
			return ((JvmDeclaredType) modelElement).getMembers().isEmpty();
		}
		return super.isLeaf(modelElement);
	}

	@Override
	protected XtendOutlineNodeFactory getOutlineNodeFactory() {
		return (XtendOutlineNodeFactory) super.getOutlineNodeFactory();
	}

}
